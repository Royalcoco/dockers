pip install streamlit numpy pandas scipy matplotlib yfinance scikit-learn
streamlit run dashboard.py

# === PLAN TECHNIQUE COMPLET ===
# Objectif : Int√©grer un mod√®le LPPL + SMB + analyse avanc√©e pour d√©tecter √† l'avance les bulles sp√©culatives,
# cracks boursiers et signaux de d√©s√©quilibres structurels (sp√©culation, instabilit√© syst√©mique).

# === MODULES REQUIS ===
# pip install streamlit numpy pandas scipy matplotlib yfinance scikit-learn

# === STRUCTURE ===
# 1. smb_model.py : Mod√®le SMB (stabilit√© mon√©taire bancaire)
# 2. lppl_model.py : Mod√®le LPPL (pr√©vision des cracks)
# 3. risk_model.py : Analyse pr√©dictive du risque bas√© sur d√©riv√©es du march√© (volatilit√©, RSI, MACD, etc.)
# 4. dashboard.py : Interface utilisateur Streamlit

# === CODE ===

# === smb_model.py ===
def compute_smb(D, Q, L, R, CPI, v, i, S, B, Vol):
    phi1, phi2, phi3 = 0.5, 0.3, -0.2
    lambda_t = phi1 * S + phi2 * B + phi3 * Vol
    M_eff = D + Q - L - R
    P_adj = CPI * (1 + v) * (1 + 0.3 * i)
    V_B = M_eff / P_adj * lambda_t
    SMB_index = V_B / (D + Q)
    return SMB_index

# === lppl_model.py ===
import numpy as np
from scipy.optimize import curve_fit

def lppl(t, A, B, C, tc, m, w, phi):
    epsilon = 1e-6
    return A + B * np.power(tc - t + epsilon, m) + C * np.power(tc - t + epsilon, m) * np.cos(w * np.log(tc - t + epsilon) + phi)

def fit_lppl_model(prices):
    t = np.arange(len(prices))
    p0 = [max(prices), -1, 1, len(prices)+10, 0.5, 7, 0]
    bounds = ([0, -np.inf, -np.inf, len(prices), 0.1, 5, -np.pi], [np.inf, 0, np.inf, len(prices)+100, 1, 15, np.pi])
    try:
        popt, _ = curve_fit(lppl, t, prices, p0=p0, bounds=bounds, maxfev=10000)
        return popt
    except Exception as e:
        return None

# === risk_model.py ===
import numpy as np
from sklearn.preprocessing import MinMaxScaler

def compute_technical_indicators(prices):
    returns = np.diff(prices) / prices[:-1]
    volatility = np.std(returns[-20:])
    momentum = np.mean(returns[-5:])
    rolling_avg = np.mean(prices[-20:])
    drawdown = (max(prices[-30:]) - prices[-1]) / max(prices[-30:])
    return volatility, momentum, rolling_avg, drawdown

def estimate_market_risk(prices):
    vol, mom, avg, dd = compute_technical_indicators(prices)
    score = 0.4 * vol + 0.3 * abs(mom) + 0.2 * dd + 0.1 * (avg / prices[-1])
    scaler = MinMaxScaler((0, 1))
    return float(np.clip(score, 0, 1))

# === dashboard.py ===
import streamlit as st
import yfinance as yf
import matplotlib.pyplot as plt
from smb_model import compute_smb
from lppl_model import fit_lppl_model, lppl
from risk_model import estimate_market_risk

st.set_page_config(layout="wide")
st.title("üìâ Syst√®me d'Alerte Financi√®re Pr√©dictive : SMB + LPPL + Risque")

# S√©lection d'un actif boursier
ticker = st.sidebar.text_input("Entrez un symbole boursier (ex: ^GSPC pour S&P 500)", "^GSPC")
data = yf.download(ticker, start="2005-01-01")['Adj Close']
st.line_chart(data[-500:])

# Section LPPL
st.subheader("üîÆ D√©tection de bulle via mod√®le LPPL")
data_trimmed = data[-250:]
prices = data_trimmed.values
params = fit_lppl_model(prices)

if params is not None:
    t = np.arange(len(prices))
    pred = lppl(t, *params)
    fig, ax = plt.subplots()
    ax.plot(t, prices, label="Prix r√©el")
    ax.plot(t, pred, label="Mod√®le LPPL", linestyle="--")
    ax.axvline(x=params[3], color='red', linestyle=':', label=f"Pr√©vision crack t_c={int(params[3])}")
    ax.legend()
    st.pyplot(fig)
else:
    st.warning("√âchec de l'ajustement du mod√®le LPPL. Essayez un autre actif.")

# Section SMB
st.subheader("üè¶ Indice de Stabilit√© Mon√©taire Bancaire (SMB)")
col1, col2 = st.columns(2)
with col1:
    D = st.slider("D√©p√¥ts bancaires", 500, 2000, 1000)
    Q = st.slider("Actifs liquides", 0, 500, 200)
    L = st.slider("Encours de pr√™ts", 100, 1500, 600)
    R = st.slider("R√©serves obligatoires", 0, 500, 100)
with col2:
    CPI = st.slider("Indice des prix (CPI)", 80, 150, 110)
    v = st.slider("Vitesse de circulation", 0.01, 0.2, 0.05)
    i = st.slider("Taux d'int√©r√™t", 0.01, 0.1, 0.03)
    S = st.slider("Stabilit√© bancaire", 0.0, 1.0, 0.8)
    B = st.slider("Indice du secteur bancaire", 0.0, 1.0, 0.7)
    Vol = st.slider("Volatilit√© march√©", 0.0, 0.5, 0.2)

smb_val = compute_smb(D, Q, L, R, CPI, v, i, S, B, Vol)
st.metric("Indice SMB", f"{smb_val:.2f}", delta=None)

if smb_val < 0.9:
    st.error("‚ö†Ô∏è Risque de d√©s√©quilibre mon√©taire : attention √† la liquidit√© du syst√®me.")
elif smb_val > 1.2:
    st.success("‚úÖ Stabilit√© bancaire solide.")
else:
    st.info("‚ÑπÔ∏è Stabilit√© mod√©r√©e. Surveiller les indicateurs.")

# Section Risque
st.subheader("üìä Indice de Risque de Sp√©culation")
market_risk = estimate_market_risk(prices)
st.metric("Score de risque march√© (0-1)", f"{market_risk:.2f}")

if market_risk > 0.7:
    st.warning("‚ö†Ô∏è Risque √©lev√© de surchauffe sp√©culative.")
elif market_risk < 0.3:
    st.success("‚úÖ Risque faible. March√© stable.")
else:
    st.info("‚ÑπÔ∏è Risque mod√©r√©. Surveiller la volatilit√©.")
