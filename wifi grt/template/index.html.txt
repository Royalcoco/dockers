<!DOCTYPE html>
<html lang:#C:/Users/salib/OneDrive/Bureau/web_deploy/import subprocess/import re

ia_clients = {$}

@app.route("/scan_clients")
def scan_clients():
    try:
        result = subprocess.check_output(["arp", "-a"]).decode()
        lines = result.strip().split("\n")

        ia_clients.clear()
        for line in lines:
            match = re.search(r"\((.*?)\) at ([\w:]+)", line)
            if match:
                ip, mac = match.groups()
                alias = f"!Element_{mac[-5:].replace(':','')}"
                ia_clients[alias] = {"ip": ip, "mac": mac}

        return jsonify({"status": "OK", "clients": ia_clients})
    except Exception as e:
        return jsonify({"status": "ERROR", "error": str(e)})
<html">,://="fr‚Ç¨‚Ç¨.from [$]">
Flask
requests
bs4
google-search-results

<html lang="fr"></html>
<html lang="fr"></html>
services:
  - type: web
    name: serp-api-app
    env: python
    plan: free
    buildCommand: "pip install -r requirements.txt"
    startCommand: "python serp_api_scraper_extended.py"
serp-glyph-crypto-hub/
‚îú‚îÄ‚îÄ app.py                         # Flask main server
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ hub.html                   # Interface web glyph/crypto
‚îú‚îÄ‚îÄ windows_glyphs.json           # Glyphes syst√®me Windows enrichis
‚îú‚îÄ‚îÄ requirements.txt              # D√©pendances
‚îú‚îÄ‚îÄ VoiceGlyphListener.ps1        # √âcouteur vocal PowerShell
‚îú‚îÄ‚îÄ serp_api_scraper_extended.py  # Scraper SERP + SQLite + threads
‚îú‚îÄ‚îÄ glyph_registry.json           # Glyphes g√©n√©r√©s
‚îú‚îÄ‚îÄ sealed_glyphs/                # Snapshots cryptodocker
‚îî‚îÄ‚îÄ README.md                     # Instructions d√©ploiement
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Hotspot Sniffer 9000</title>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status);
        }

        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }

        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
        }
    </script>
</head>
<body>
    <h1>Hotspot Sniffer 9000 üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
</html>
<head>
    <meta charset="UTF-8">
    <title>Hotspot Sniffer 9000</title>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status);
        }

        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }

        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
        }
    </script>
</head>
<body>
    <h1>Hotspot Sniffer 9000 üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse\sudo python3 app.py"></p>
</body>
</html>
from flask import Flask, request, jsonify
import subprocess
import os
import threading
sudo python3 app.py
# This script sets up a Flask web application that captures network traffic using tcpdump,
# extracts DNS queries, and provides a mock AI response for user input.
import subprocess
import os
import threading

app = Flask(__name__)
CAPTURE_FILE = "capture.pcap"

def start_tcpdump():
    if os.path.exists(CAPTURE_FILE):
        os.remove(CAPTURE_FILE)
    subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", CAPTURE_FILE, "-c", "100"], check=True)

@app.route("/start", methods=["POST"])
def start_capture():
    thread = threading.Thread(target=start_tcpdump)
    thread.start()
    return jsonify({"status": "Capture started"}), 200

@app.route("/dns", methods=["GET"])
def get_dns():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", CAPTURE_FILE, "port", "53"])
        lines = result.decode().split("\n")
        response = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": response}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text")
    # IA de fortune pour faire semblant d‚Äô√™tre intelligente
    if "youtube" in user_input:
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input:
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})

if __name__ == "__main__":
    app.run(debug=True)

import subprocess

def start_capture(interface="wlan0", output="capture.pcap"):
    try:
        subprocess.run(["sudo", "tcpdump", "-i", interface, "-w", output], check=True)
    except subprocess.CalledProcessError as e:
        print("Erreur de capture :", e)

def extract_dns_queries(pcap_file):
    try:
        output = subprocess.check_output(["tcpdump", "-nnr", pcap_file, "port", "53"])
        print(output.decode())
    except subprocess.CalledProcessError as e:
        print("Erreur extraction DNS :", e)

# Exemple d'utilisation
start_capture()  # appuie sur CTRL+C pour arr√™ter manuellement
# Puis :
# extract_dns_queries("capture.pcap")
# Note: This code requires root privileges to run tcpdump.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run tcpdump.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run tcpdump.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run tcpdump.
import os
import hashlib
import random
import string
from datetime import datetime

def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            wifi_data.append((ssid, bssid, signal))
    return wifi_data

def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    return f"{ssid} => {symbols} | {hash_hex[:10]}"

def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")

if __name__ == "__main__":
    wifi_list = scan_wifi()
    symbols = [generate_symbolic_crypto(ssid, bssid, signal) for ssid, bssid, signal in wifi_list]
    save_to_notepad(symbols)
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
import os
import time

def lock_file(filepath):
    print(f"Blocage simul√© du fichier : {filepath}")
    try:
        # Ouvre le fichier en exclusif (mode lecture seule)
        with open(filepath, "rb") as f:
            print("Fichier ouvert et maintenu...")
            while True:
                time.sleep(1)  # La boucle qui dit "je te tiens"
    except Exception as e:
        print(f"Erreur : {e}")

def main():
    target = input("Chemin du fichier √† bloquer : ").strip()
    if os.path.exists(target):
        lock_file(target)
    else:
        print("Fichier introuvable.")

if __name__ == "__main__":
    main()
# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code is a simulation and does not actually lock files.
/ton-dossier/
‚îÇ
‚îú‚îÄ‚îÄ app.py               # Backend Flask
‚îú‚îÄ‚îÄ monitor.py           # Scan + Crypto
‚îú‚îÄ‚îÄ lock.py              # Fichier bloqu√©
‚îî‚îÄ‚îÄ templates/
    ‚îî‚îÄ‚îÄ index.html       # Interface Web
from flask import Flask, request, jsonify, render_template
import subprocess
import threading
from monitor import scan_wifi, generate_symbolic_crypto, save_to_notepad

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

@app.route("/start-hotspot", methods=["POST"])
def start_hotspot():
    try:
        subprocess.run(["nmcli", "dev", "wifi", "hotspot", "ifname", "wlan0", "ssid", "Hotspot_H4X", "password", "UltraSecret42"], check=True)
        return jsonify({"status": "Hotspot lanc√©"}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/scan", methods=["POST"])
def scan():
    wifi_data = scan_wifi()
    cryptos = [generate_symbolic_crypto(ssid, bssid, signal) for ssid, bssid, signal in wifi_data]
    save_to_notepad(cryptos)
    return jsonify({"crypto_symbols": cryptos}), 200

if __name__ == "__main__":
    app.run(debug=True)
import os
import hashlib
import random
import string
from datetime import datetime

def scan_wifi():
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            wifi_data.append((ssid, bssid, signal))
    return wifi_data

def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    return f"{ssid} => {symbols} | {hash_hex[:10]}"

def save_to_notepad(symbols_list):
    with open("wifi_crypto_log.txt", "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
import os
import time

def lock_file(filepath):
    print(f"Blocage simul√© du fichier : {filepath}")
    try:
        with open(filepath, "rb") as f:
            print("Fichier ouvert. Appuyez sur Ctrl+C pour lib√©rer.")
            while True:
                time.sleep(1)
    except Exception as e:
        print(f"Erreur : {e}")

if __name__ == "__main__":
    path = input("Chemin du fichier √† verrouiller : ").strip()
    if os.path.exists(path):
        lock_file(path)
    else:
        print("Fichier introuvable.")
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Contr√¥le R√©seau üîê</title>
    <script>
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }

        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
    </script>
</head>
<body>
    <h1>üõ∞Ô∏è Crypto-WiFi Console</h1>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
</body>sudo python3 app.py
</html>

<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Hotspot Sniffer 9000</title>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status);
        }

        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }

        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
        }
    </script>
</head>
<body>
    <h1>Hotspot Sniffer 9000 üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse\sudo python3 app.py"></p>
</body>
</html>
import os
import subprocess
import threading
from flask import Flask, request, jsonify, render_template
app = Flask(__name__)
CAPTURE_FILE = "capture.pcap"
def start_tcpdump():
    if os.path.exists(CAPTURE_FILE):
        os.remove(CAPTURE_FILE)
    subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", CAPTURE_FILE, "-c", "100"], check=True)
@app.route("/start", methods=["POST"])
def start_capture():
    thread = threading.Thread(target=start_tcpdump)
    thread.start()
    return jsonify({"status": "Capture started"}), 200
@app.route("/dns", methods=["GET"])
def get_dns():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", CAPTURE_FILE, "port", "53"])
        lines = result.decode().split("\n")
        response = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": response}), 200
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text")
    if "youtube" in user_input:
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input:
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
if __name__ == "__main__":
    app.run(debug=True)
import os
import hashlib
import random
import string
from datetime import datetime
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
if __name__ == "__main__":
    wifi_list = scan_wifi()
    symbols = [generate_symbolic_crypto(ssid, bssid, signal) for ssid, bssid, signal in wifi_list]
    save_to_notepad(symbols)
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
Execute : sudo python3 app.py
sudo tcpdump -i wlan0 -A port 80 > http_dump.log
import random
import subprocess
import time

def simulate_fake_requests(domains):
    print("Simulation de trafic pour couvrir les traces...")
    while True:
        domain = random.choice(domains)
        try:
            subprocess.run(["curl", f"http://{domain}"], timeout=5)
        except Exception:
            pass
        time.sleep(random.uniform(1, 3))

console.log(navigator.connection);
def disable_wifi():
    print("Tentative de coupure Wi-Fi...")
    subprocess.run(["nmcli", "radio", "wifi", "off"])
if __name__ == "__main__":
    print("Analyse du trafic sortant en cours...")
    domains = extract_domains_from_log("http_dump.log")
    disable_wifi()
    print("Connexion coup√©e. Remplacement par du trafic simul√©...")
    simulate_fake_requests(domains)

import os
import time
import subprocess

def scan_and_connect(target_ssid):
    print(f"Scan des r√©seaux Wi-Fi...")
    result = os.popen("nmcli dev wifi").read()
    if target_ssid not in result:
        print("Hotspot cible non trouv√©.")
        return False
    os.system(f"nmcli dev wifi connect '{target_ssid}' password 'tape_ton_guess_ici'")
    print(f"Connect√© √† {target_ssid}")
    return True

def simulate_data_exchange():
    try:
        print("Envoi de faux √©changes r√©seau...")
        subprocess.run(["ping", "-c", "4", "8.8.8.8"])
        subprocess.run(["curl", "http://example.com"])
        print("Faux trafic envoy√©.")
    except Exception as e:
        print(f"Erreur : {e}")

def main():
    ssid = input("Nom du hotspot cible : ").strip()
    if scan_and_connect(ssid):
        time.sleep(3)
        simulate_data_exchange()

if __name__ == "__main__":
    main()

def extract_domains_from_log(filepath):
    domains = set()
    with open(filepath, "r") as f:
        for line in f:
            if "Host:" in line:
                parts = line.strip().split()
                if len(parts) >= 2:
                    domains.add(parts[1])
    return list(domains)
üì† scan_fax_simulator.py      ‚Üí Envoie un faux "scan fax" √† une imprimante/proxy sur le r√©seau
üîä voiceprint_emulator.py     ‚Üí G√©n√®re une empreinte vocale IA unique par cible
üîê keyboard_lock.py           ‚Üí Simule un clavier crypt√© d√©verrouillable uniquement via cette empreinte
üåê proxy_network.py           ‚Üí Balaye le r√©seau pour toutes les machines "faxables"
üî£ symbol_transmitter.py      ‚Üí Envoie les symboles de fermeture incompr√©hensibles √† chaque noeud
import os
import subprocess
import time
from flask import Flask, request, jsonify, render_template
app = Flask(__name__)
@app.route("/")
def index():
    return render_template("index.html")
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        return jsonify({"status": "Capture started"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        response = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": response}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text")
    if "youtube" in user_input:
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input:
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
if __name__ == "__main__":
    app.run(debug=True)
import os
import hashlib
import random
import string
from datetime import datetime
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
if __name__ == "__main__":
    wifi_list = scan_wifi()
    symbols = [generate_symbolic_crypto(ssid, bssid, signal) for ssid, bssid, signal in wifi_list]
    save_to_notepad(symbols)
def send_fax_payload(target_ip):
    print(f"[üì†] Envoi d'un faux FAX num√©rique vers {target_ip}...")
    payload = f"--FAKE-FAX--{target_ip}--"
    # Simulation d'√©criture dans une imprimante r√©seau
    with open(f"sent_fax_{target_ip.replace('.', '_')}.bin", "w") as f:
        f.write(payload)
    return payload
def scan_network_for_faxable_devices():
    print("[üåê] Balayage du r√©seau pour les appareils faxables...")
    # Simulation de d√©couverte d'appareils faxables
    devices = ["def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    return ["192.168.0.21", "192.168.0.35", "192.168.0.108"]
from proxy_network import discover_proxy_devices
from scan_fax_simulator import send_fax_payload
from voiceprint_emulator import generate_voiceprint
from keyboard_lock import keyboard_access
from symbol_transmitter import generate_symbols

devices = discover_proxy_devices()

for ip in devices:
    print("\n----- Traitement du p√©riph√©rique", ip, "-----")
    fax = send_fax_payload(ip)
    vp = generate_voiceprint(ip)
    
    print("[üé§] V√©rification clavier avec empreinte vocale...")
    if keyboard_access(vp, vp):
        print("[‚úÖ] Appareil autoris√© √† lire le fax.")
    else:
        print("[‚ùå] Appareil rejet√©.")
    
    generate_symbols()
import random
import string

def generate_symbols():
    symbols = ''.join(random.choices(string.ascii_uppercase + string.digits + "!@#¬•‚Çø%&*", k=20))
    print(f"[üî£] Envoi de symboles impossibles : {symbols}")
    return symbols
def keyboard_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Clavier d√©verrouill√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        return False
        def send_fax_payload(target_ip):
    print(f"[üì†] Envoi d'un faux FAX num√©rique vers {target_ip}...")
    payload = f"--FAKE-FAX--{target_ip}--"
    # Simulation d'√©criture dans une imprimante r√©seau
    with open(f"sent_fax_{target_ip.replace('.', '_')}.bin", "w") as f:
        f.write(payload)
    return payload

import hashlib

def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {target_ip}")
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]  
    
    return devices
    "    "
    def encode_trace_wipe():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # Le message 'wipe' est cach√© dans des symboles non interpr√©tables
    hidden_pattern = ''.join(random.choices("‚àÜ¬§√∏‚Ä†¬•‚âà‚â†¬ß", k=8))
    final_payload = f"{hidden_pattern}-W1P3D-{hidden_pattern[::-1]}"
    print(f"[üìú] Signature de nettoyage : {final_payload}")
    return final_payload
from proxy_network import discover_proxy_devices
from scan_fax_simulator import send_fax_payload
from voiceprint_emulator import generate_voiceprint
from keyboard_lock import keyboard_access
from symbol_transmitter import generate_symbols, encode_trace_wipe
import os

devices = discover_proxy_devices()
logs = []

for ip in devices:
    print("\n----- Traitement du p√©riph√©rique", ip, "-----")
    fax = send_fax_payload(ip)
    vp = generate_voiceprint(ip)
    
    if keyboard_access(vp, vp):
        print("[‚úÖ] Appareil autoris√© √† lire le fax.")
        logs.append(f"ACCESS {ip}")
    else:
        print("[‚ùå] Appareil rejet√©.")
        logs.append(f"DENIED {ip}")
    
    generate_symbols()

# Nettoyage final
wipe_signature = encode_trace_wipe()

# Efface les fichiers temporaires/fax simul√©s
for ip in devices:
    fname = f"sent_fax_{ip.replace('.', '_')}.bin"
    if os.path.exists(fname):
        os.remove(fname)
        print(f"[üóëÔ∏è] Fax {fname} supprim√©.")

# Supprime les logs de session (ici simul√©s en RAM)
logs.clear()
print("[üíæ] Journaux effac√©s de la m√©moire volatile.")

print(f"\n[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code is a simulation and does not actually lock files.
sector clean :[üì†] Envoi d'un faux FAX num√©rique vers 192.168.0.35...
[üîä] G√©n√©ration d'empreinte vocale IA pour 192.168.0.35
Empreinte vocale : 94ff81d28e4e3a7d
[üé§] V√©rification clavier avec empreinte vocale...
[üîì] Clavier d√©verrouill√©.
[üî£] Envoi de symboles impossibles : X9A8Z!@#‚Çø1YE
[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...
[üìú] Signature de nettoyage : ‚àÜ¬•¬ß¬§√∏‚Ä†¬•-W1P3D-¬•‚Ä†√∏¬§¬ß¬•‚àÜ
[üóëÔ∏è] Fax sent_fax_192_168_0_35.bin supprim√©.
[üíæ] Journaux effac√©s de la m√©moire volatile.

[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : ‚àÜ¬•¬ß¬§√∏‚Ä†¬•-W1P3D-¬•‚Ä†√∏¬§¬ß¬•‚àÜ
from symbol_transmitter import encode_trace_wipe
import os
sport: sudo python3 app.py --host=0.0.0.0 --port=8080
from flask import Flask, jsonify
from proxy_network import discover_proxy_devices
app = Flask(__name__)
@app.route("/")
def index():
    return "<h1>Hotspot Sniffer 9000</h1><p>Utilisez les endpoints pour interagir avec le syst√®me.</p>"
@app.route("/discover", methods=["GET"])
def discover():
    devices = discover_proxy_devices()
    return jsonify({"devices": devices})
    return ngrok http 8080

@app.route("/terminate", methods=["POST"])
def terminate_ops():
    devices = discover_proxy_devices()
    for ip in devices:
        fname = f"sent_fax_{ip.replace('.', '_')}.bin"
        if os.path.exists(fname):
            os.remove(fname)
    wipe_signature = encode_trace_wipe()
    return jsonify({"signature": wipe_signature})
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    <h2>üîö Cl√¥turer la s√©quence de scan</h2>
<button onclick="terminateOps()">FERMER LA BOUCLE</button>
<p id="signatureResult"></p>

<script>
    async function terminateOps() {
        const res = await fetch('/terminate', {method: 'POST'});
        const data = await res.json();
        document.getElementById("signatureResult").innerText = "Empreinte d'effacement : " + data.signature;
    }
</script>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>üß† Matrix Control Interface</title>
    <style>
        body {
            background-color: black;
            color: #00ff00;
            font-family: monospace;
            text-align: center;
            padding-top: 5vh;
        }
        button {
            background: black;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin: 20px;
        }
        button:hover {
            background: #003300;
        }
        #matrixCanvas {
            position: fixed;
            top: 0;
            left: 0;
            z-index: -1;
        }
    </style>
</head>
<body>
    <canvas id="matrixCanvas"></canvas>

    <h1>üß† FERMETURE DU R√âSEAU EN COURS</h1>
    <h2>INTERFACE D'OP√âRATION :: MONDAY</h2>

    <button onclick="terminateOps()">FERMER LA BOUCLE</button>
    <p id="signatureResult"></p>

    <script>
        async function terminateOps() {
            const res = await fetch('/terminate', { method: 'POST' });
            const data = await res.json();
            const signature = data.signature;
            document.getElementById("signatureResult").innerText = "Empreinte d'effacement : " + signature;

            const msg = new SpeechSynthesisUtterance("Cycle termin√©. Les donn√©es ont √©t√© purg√©es.");
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }

        // Matrix code rain animation
        const canvas = document.getElementById("matrixCanvas");
        const ctx = canvas.getContext("2d");

        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;

        const letters = "„Ç¢„Ç§„Ç¶„Ç®„Ç™„Ç´„Ç≠„ÇØ„Ç±„Ç≥„Çµ„Ç∑„Çπ„Çª„ÇΩ„Çø„ÉÅ„ÉÑ„ÉÜ„Éà„Éä„Éã„Éå„Éç„ÉéABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        const fontSize = 14;
        const columns = canvas.width / fontSize;

        const drops = Array.from({ length: columns }).fill(1);

        function draw() {
            ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "#0F0";
            ctx.font = fontSize + "px monospace";

            for (let i = 0; i < drops.length; i++) {
                const text = letters.charAt(Math.floor(Math.random() * letters.length));
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }

                drops[i]++;
            }
        }

        setInterval(draw, 33);
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Hotspot Sniffer 9000</title>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status);
        }

        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }

        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
    </script>
</head>
<body>
    <h1>Hotspot Sniffer 9000 üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
</body>
import subprocess
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        print("Capture d√©marr√©e. Appuyez sur CTRL+C pour arr√™ter.")
    except subprocess.CalledProcessError as e:
        print("Erreur de capture :", e)
def extract_dns_queries(capture_file):
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", capture_file, "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        print("Requ√™tes DNS extraites :")
        for query in dns_queries:
            print(query)
    except subprocess.CalledProcessError as e:
        print("Erreur lors de l'extraction des requ√™tes DNS :", e)
def ai_response(user_input):
    if "youtube" in user_input:
        return "Ah, encore un qui mate des vid√©os pendant les heures de cours."
    elif "google" in user_input:
        return "Chercher des trucs, hein ? Fascinant."
    else:
        return "Hmm... je vois √ßa. Rien de tr√®s palpitant."
if __name__ == "__main__":
    print("Bienvenue dans Hotspot Sniffer 9000 !")
    print("1. D√©marrer la capture de trafic")
    print("2. Extraire les requ√™tes DNS")
    print("3. Parler √† l'IA")
    
    choice = input("Choisissez une option (1/2/3) : ")
    
    if choice == "1":
        start_capture()
    elif choice == "2":
        capture_file = input("Entrez le nom du fichier de capture (par d√©faut 'capture.pcap') : ") or "capture.pcap"
        extract_dns_queries(capture_file)
    elif choice == "3":
        user_input = input("Parlez √† l'IA : ")
        response = ai_response(user_input)
        print("IA :", response)
    else:
        print("Option invalide.")
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code requires root privileges to run nmcli and access Wi-Fi information.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
import os
import time
def lock_file(filepath):
    print(f"Blocage simul√© du fichier : {filepath}")
    try:
        # Ouvre le fichier en mode binaire pour le verrouiller
        with open(filepath, "rb") as f:
            # Simule le blocage en maintenant le fichier ouvert
            print("Fichier ouvert. Appuyez sur Ctrl+C pour lib√©rer.")
            while True:
                time.sleep(1)  # Maintient le script en cours d'ex√©cution
    except KeyboardInterrupt:
        print("Blocage lib√©r√© par l'utilisateur.")
    except Exception as e:
        print(f"Erreur : {e}")
def main():
    path = input("Chemin du fichier √† verrouiller : ").strip()
    if os.path.exists(path):
        lock_file(path)
    else:
        print("Fichier introuvable.")
if __name__ == "__main__":
    main()
    import subprocess

def start_capture(interface="wlan0", output="capture.pcap"):
    try:
        subprocess.run(["sudo", "tcpdump", "-i", interface, "-w", output], check=True)
    except subprocess.CalledProcessError as e:
        print("Erreur de capture :", e)

def extract_dns_queries(pcap_file):
    try:
        output = subprocess.check_output(["tcpdump", "-nnr", pcap_file, "port", "53"])
        print(output.decode())
    except subprocess.CalledProcessError as e:
        print("Erreur extraction DNS :", e)

# Exemple d'utilisation
start_capture()  # appuie sur CTRL+C pour arr√™ter manuellement
# Puis :
# extract_dns_queries("capture.pcap")


# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
# Note: This code is a simulation and does not actually lock files.
# Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.
from flask import Flask, render_template, jsonify
import subprocess
import os
from wifi_scanner import scan_wifi, generate_symbolic_crypto, save_to_notepad
app = Flask(__name__)
@app.route("/")
def index():
    return render_template("index.html")
@app.route("/start-hotspot", methods=["POST"])
def start_hotspot():
    try:
        # Commande pour d√©marrer le hotspot
        subprocess.run(["nmcli", "device", "wifi", "hotspot", "ifname", "wlan0", "ssid", "HotspotCrypto", "password", "tape_ton_guess_ici"], check=True)
        return jsonify({"status": "Hotspot started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/scan", methods=["POST"])
def scan():
    wifi_list = scan_wifi()
    cryptos = [generate_symbolic_crypto(ssid, bssid, signal) for ssid, bssid, signal in wifi_list]
    save_to_notepad(cryptos)
    return jsonify({"crypto_symbols": cryptos}), 200
@app.route("/lock-file", methods=["POST"])
def lock_file():
    filepath = request.json.get("filepath")
    if not filepath or not os.path.exists(filepath):
        return jsonify({"error": "File not found"}), 404
    try:
        # Simulate file locking
        subprocess.run(["python3", "lock_file.py", filepath], check=True)
        return jsonify({"status": "File locked successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
if __name__ == "__main__":
    app.run(debug=True, host="\:_.<local:http>._:\
<!-- <local:http>::\_INIT_SEQUENCE_ -->

<body>
    <h1>Matrix Interface</h1>
    <button onclick="terminateOps()">FERMER LA BOUCLE</button>
    <p id="iaMessages"></p>

    <script>
        // Rep√®re la balise mythique pour d√©ploiement
        const tagSignal = document.querySelector('body').innerHTML.includes('<local:http>');
        
        if (tagSignal) {
            fetch('/ia/init')
                .then(res => res.json())
                .then(data => {
                    document.getElementById('iaMessages').innerText = data.msg;
                    const voice = new SpeechSynthesisUtterance(data.vocal);
                    voice.lang = "fr-FR";
                    voice.rate = 0.75;
                    voice.pitch = 0.4;
                    speechSynthesis.speak(voice);
                });
        }
    </script>
</body>
@app.route('/ia/init')
def ia_init():
    # Simulation IA entre bots
    import base64
    ping = base64.b64encode(b'INIT::ENTITY_443::ACTIVATE').decode()
    pong = base64.b64encode(b'RESPONSE::OK::DEPLOYED').decode()
    return jsonify({
        "msg": f">> PING::{ping} \n<< RECV::{pong}",
        "vocal": "Connexion au noyau IA confirm√©e. Transmission encod√©e en cours."
    })
app.run(debug=True, host="\:_.<local:http>._:\ </local:http>")
app.run(debug=True, host="0.0.0.0", port=8080)
    "}
    <local:http>
        <host>
            <ip>
                <local:http>._:\
                <port>8080</port>
                </ip>
                </host>
                <local:http>._:\ </port>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http:end>._:\ </local:http:end>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
                <local:http>._:\ </local:http>
<param name="local" value="$CASH$">
    </local:http:end>
    <title>Crypto-WiFi Console</title>
    <script>
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }

        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
    </script>
</head>
<body>
    <h1>Hotspot Sniffer 9000 üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <button onclick="lockFile()">Verrouiller un Fichier</button>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
    <p>Note: This code requires root privileges to run nmcli and access Wi-Fi information.</p>
</body>
</html>
import os
import subprocess
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
import random
import string
import hashlib
import datetime
import subprocess
def extract_domains_from_log(filepath):
    domains = set()
    with open(filepath, "r") as f:
        for line in f:
            if "Host:" in line:
                parts = line.strip().split()
                if len(parts) >= 2:
                    domains.add(parts[1])
    return list(domains)
def simulate_fake_requests(domains):
    print("Simulation de requ√™tes HTTP vers les domaines extraits...")
    for domain in domains:
        try:
            subprocess.run(["curl", "-s", f"http://{domain}"], check=True)
            print(f"Requ√™te envoy√©e √† {domain}")
        except subprocess.CalledProcessError as e:
            print(f"Erreur lors de l'envoi √† {domain} : {e}")
def scan_and_connect(target_ssid):
    print(f"Scan des r√©seaux Wi-Fi pour {target_ssid}...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3 and parts[0] == target_ssid:
            bssid, signal = parts[1], parts[2]
            print(f"R√©seau trouv√© : {target_ssid} ({bssid}, Signal: {signal})")
            break
    else:
        print(f"R√©seau {target_ssid} non trouv√©.")
        return False

    # Connexion au r√©seau
    try:
        subprocess.run(["nmcli", "device", "wifi", "connect", target_ssid], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Erreur de connexion : {e}")
        return False
    print(f"Connect√© √† {target_ssid} avec succ√®s.")
    return True
if __name__ == "__main__":
    target_ssid = input("Entrez le SSID du r√©seau √† scanner et connecter : ").strip()
    if scan_and_connect(target_ssid):
        log_file = "dns_log.txt"
        domains = extract_domains_from_log(log_file)
        if domains:
            simulate_fake_requests(domains)
        else:
            print("Aucun domaine trouv√© dans le fichier de log.")
    else:
        print("√âchec de la connexion au r√©seau.")
import os
import subprocess
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return devices
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text", "").lower()
    if "youtube" in user_input:
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input:
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
import hashlib
import random
import string
import os
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            print(f"R√©seau trouv√© : SSID={ssid}, BSSID={bssid}, Signal={signal}")
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©s pour {ssid}: {symbols}")
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
def send_fax_payload(target_ip):
    print(f"[üì†] Envoi d'un faux FAX num√©rique vers {target_ip}...")
    # Simulation d'un payload de fax
    payload = f"--FAKE-FAX--{target_ip}--"
    # Simulation d'√©criture dans une imprimante r√©seau
    with open(f"sent_fax_{target_ip.replace('.', '_')}.bin", "w") as f:
        f.write(payload)
    return payload
    return devices
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    "       devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {target_ip}")
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return devices
def keyboard_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Clavier d√©verrouill√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        return False
def generate_symbols():
    print("[üî£] Envoi de symboles impossibles...")
    # G√©n√©ration de symboles al√©atoires
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©s : {symbols}")
    return symbols
def keyboard_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Clavier d√©verrouill√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
    return False
def send_fax_payload(target_ip):
    print(f"[üì†] Envoi d'un faux FAX num√©rique vers {target_ip}...")
    # Simulation d'un payload de fax
    payload = f"--FAKE-FAX--{target_ip}--"
    # Simulation d'√©criture dans une imprimante r√©seau
    with open(f"sent_fax_{target_ip.replace('.', '_')}.bin", "w") as f:
        f.write(payload)
    return payload
def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {target_ip}")
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    return devices
    return devices
def encode_trace_wipe():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    import random
    import string
    hidden_pattern = ''.join(random.choices("‚àÜ¬§√∏‚Ä†¬•‚âà‚â†¬ß", k=8))
    hidden_pattern = hidden_pattern.replace("√∏", "0").replace("¬•", "Y").replace("¬ß", "S")
    final_payload = f"{hidden_pattern}-W1P3D-{hidden_pattern}"
    print(f"[üìú] Signature de nettoyage : {final_payload}")
    return final_payload
    return devices
def encode_trace_wipe():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    import random
    import string
    hidden_pattern = ''.join(random.choices("‚àÜ¬§√∏‚Ä†¬•‚âà‚â†¬ß", k=8))
    hidden_pattern = hidden_pattern.replace("√∏", "0").replace("¬•", "Y").replace("¬ß", "S")
    final_payload = f"{hidden_pattern}-W1P3D-{hidden_pattern}"
    print(f"[üìú] Signature de nettoyage : {final_payload}")
    return final_payload
# Nettoyage final
devices = discover_proxy_devices()
wipe_signature = encode_trace_wipe()
import os
import time
# Supprime les fichiers de fax envoy√©s
for device in devices:
    fname = f"sent_fax_{device.replace('.', '_')}.bin"
    print(f"[üóëÔ∏è] Suppression du fax {fname}...")
    if os.path.exists(fname):
        os.remove(fname)
        print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
    else:
        print(f"[‚ùå] Fax {fname} introuvable.")
print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return  ref.where(/npm/, array-contains, /* value */)
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
    return devices
from symbol_transmitter import generate_symbols
from trace_wiper import encode_trace_wipe
import os
from flask import Flask, jsonify, request
from flask import Flask, jsonify, request
import os
from flask import Flask, jsonify, request
app = Flask(__name__)
@app.route("/")
def index():
    return "<h1>üß† Interface de Contr√¥le de la Matrice</h1><p>Utilisez les endpoints pour interagir avec le syst√®me.</p>"
@app.route("/discover", methods=["GET"])
def discover():
    devices = discover_proxy_devices()
    print(f"[üîç] Appareils d√©couverts : {devices}")
    if not devices:
        return jsonify({"error": "Aucun appareil trouv√©"}), 404
    return jsonify({"devices": devices}), 200
@app.route("/terminate", methods=["POST"])
def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
@app.route("/symbols", methods=["GET"])
def get_symbols():
    symbols = generate_symbols()
    return jsonify({"symbols": symbols}), 200
@app.route("/lock-file", methods=["POST"])
def lock_file():
    filepath = request.json.get("filepath")
    if not filepath or not os.path.exists(filepath):
        return jsonify({"error": "File not found"}), 404
    try:
        # Simulate file locking
        subprocess.run(["python3", "lock_file.py", filepath], check=True)
        return jsonify({"status": "File locked successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
        const res = await fetch('/terminate', {method: 'POST'});
        const data = await res.json();
        const signature = data.signature || "Aucune signature g√©n√©r√©e.";
        document.getElementById('iaMessages').innerText = `Cycle termin√©. Signature d'effacement : ${signature}`;
        const msg = new SpeechSynthesisUtterance("Cycle termin√©. Signature d'effacement g√©n√©r√©e.");
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
    return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text", "").lower()
    if "youtube" in user_input:
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input:
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        print("Capture de trafic d√©marr√©e avec succ√®s.")
    except subprocess.CalledProcessError as e:
        print("Erreur lors du d√©marrage de la capture :", e)
        return False
    return True
def extract_dns_queries(capture_file="capture.pcap"):
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", capture_file, "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        if dns_queries:
            print("Requ√™tes DNS extraites :")
            for query in dns_queries:
                print(query)
        else:
            print("Aucune requ√™te DNS trouv√©e dans le fichier de capture.")
    except subprocess.CalledProcessError as e:
        print("Erreur lors de l'extraction des requ√™tes DNS :", e)
        return False
    return True
def ai_response(user_input):
    user_input = user_input.lower()
    if "youtube" in user_input:
        return "Ah, encore un qui mate des vid√©os pendant les heures de cours."
    elif "google" in user_input:
        return "Chercher des trucs, hein ? Fascinant."
    else:
        return "Hmm... je vois √ßa. Rien de tr√®s palpitant."
if __name__ == "__main__":
    print("Bienvenue dans l'interface de capture Wi-Fi et d'IA !")
    print("1. D√©marrer la capture de trafic")
    print("2. Extraire les requ√™tes DNS d'un fichier de capture")
    print("3. Parler √† l'IA")
    
    choice = input("Choisissez une option (1-3) : ").strip()
    if choice == "1":
        if start_capture():
            print("Capture de trafic d√©marr√©e avec succ√®s.")
        else:
            print("√âchec du d√©marrage de la capture.")
    elif choice == "2":
        capture_file = input("Entrez le nom du fichier de capture (par d√©faut 'capture.pcap') : ").strip() or "capture.pcap"
        if extract_dns_queries(capture_file):
            print("Requ√™tes DNS extraites avec succ√®s.")
        else:
            print("√âchec de l'extraction des requ√™tes DNS.")
    elif choice == "3":
        user_input = input("Parlez √† l'IA : ")
        response = ai_response(user_input)
        print("IA :", response)
    else:
        print("Option invalide. Veuillez choisir entre 1 et 3.")
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
# Note: This code is a simulation and does not actually lock files.
import os
import time
def lock_file(filepath):
    print(f"Verrouillage du fichier : {filepath}")
    try:
        # Ouvre le fichier en mode binaire pour simuler un verrouillage
        with open(filepath, "rb") as f:
            # Simule un verrouillage en maintenant le fichier ouvert
            print("Fichier verrouill√©. Appuyez Ctrl+C pour lib√©rer le blocage.")
            while True:
                time.sleep(1)  # Maintient le verrouillage actif
    except KeyboardInterrupt:
        print("Verrouillage lib√©r√©.")
    except Exception as e:
        print(f"Erreur lors du verrouillage du fichier : {e}")
def main():
    path = input("Entrez le chemin du fichier √† verrouiller : ").strip()
    if os.path.exists(path):
        print(f"Fichier trouv√© : {path}")
        print("Verrouillage en cours...")
        lock_file(path)
    else:
        print(f"Fichier non trouv√© : {path}. Assurez-vous que le chemin est correct.")
if __name__ == "__main__":
    main()
    app.run(debug=True, host="\local\http>._:\ </local:http>")
    app.run(debug=True, host="\local\http>._:\ </local:http>")
    app.run(debug=True, host="\local\http>._:\ </local:http>")
    app.run(debug=True, host="\local\http>._:\ </local:http>")
    app.run(debug=True, host="\local\http>._:\ </local:http>")
    app.run(debug=True, host="\local\http>._:\ </local:http>")
@app.route("/start-hotspot", methods=["POST"])
def start_hotspot():
    try:
        print("D√©marrage du hotspot Wi-Fi...")
        subprocess.run(["nmcli", "device", "wifi", "hotspot", "ifname", "wlan0", "ssid", "Hotspot9000", "password", "password123"], check=True)
        return jsonify({"status": "Hotspot started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
@app.route("/scan", methods=["POST"])
def scan():
    wifi_data = scan_wifi()
    cryptos = []
    for ssid, bssid, signal in wifi_data:
        crypto_symbol = generate_symbolic_crypto(ssid, bssid, signal)
        cryptos.append(crypto_symbol)
    print(f"Symboles g√©n√©r√©s : {cryptos}")
    save_to_notepad(cryptos)
    return jsonify({"crypto_symbols": cryptos}), 200
@app.route("/lock-file", methods=["POST"])
def lock_file():
    filepath = request.json.get("filepath")
    if not filepath or not os.path.exists(filepath):
        return jsonify({"error": "File not found"}), 404
    try:
        # Simulate file locking
        subprocess.run(["python3", "lock_file.py", filepath], check=True)
        return jsonify({"status": "File locked successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
</head>
<body>
    <h1>Crypto-WiFi Console üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <button onclick="lockFile()">Verrouiller un Fichier</button>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>

    <script>
        function startCapture() {
            fetch('/start', {method: 'POST'})
                .then(response => response.json())
                .then(data => alert(data.status || data.error));
        }

        function getDNS() {
            fetch('/dns')
                .then(response => response.json())
                .then(data => {
                    const list = document.getElementById('dnsList');
                    list.innerHTML = "";
                    data.dns_queries.forEach(q => {
                        const item = document.createElement('li');
                        item.innerText = q;
                        list.appendChild(item);
                    });
                });
        }

        function askAI() {
            const input = document.getElementById('userInput').value;
            fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            })
            .then(response => response.json())
            .then(data => {
                document.getElementById('aiResponse').innerText = data.response;
                const msg = new SpeechSynthesisUtterance(data.response);
                msg.lang = "fr-FR";
                msg.pitch = 0.4;
                msg.rate = 0.85;
                msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
                speechSynthesis.speak(msg);
            });
        }
        function startHotspot() {
            fetch('/start-hotspot', {method: 'POST'})
                .then(response => response.json())
                .then(data => alert(data.status || data.error));
        }
        function scanWiFi() {
            fetch('/scan', {method: 'POST'})
                .then(response => response.json())
                .then(data => {
                    const list = document.getElementById('cryptoList');
                    list.innerHTML = "";
                    data.crypto_symbols.forEach(symbol => {
                        const item = document.createElement('li');
                        item.innerText = symbol;
                        list.appendChild(item);
                    });
                });
        }
        function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            })
            .then(response => response.json())
            .then(data => alert(data.status || data.error));
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = aw
ait res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath: filepat
h})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChil
d(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            cons
t data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <button onclick="lockFile()">Verrouiller un Fichier</button>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
</body>
</html>
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            print(f"R√©seau trouv√© : SSID={ssid}, BSSID={bssid}, Signal={signal}")
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©s pour {ssid}: {symbols}")
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
import os
import subprocess
def extract_domains_from_log(log_file):
    print(f"Extraction des domaines du fichier de log : {log_file}")
    domains = []
    try:
        with open(log_file, "r") as f:
            for line in f:
                if "query" in line:  # Simple check for DNS queries
                    parts = line.split()
                    if len(parts) > 1:
                        domain = parts[1]
                        domains.append(domain)
    except FileNotFoundError:
        print(f"Fichier {log_file} non trouv√©.")
    return domains
def simulate_fake_requests(domains):
    print("Simulation de requ√™tes DNS factices...")
    for domain in domains:
        print(f"Requ√™te factice pour le domaine : {domain}")
        # Simulate a request (in reality, this would be more complex)
        time.sleep(0.5)  # Simulate network delay
    print("Simulation termin√©e.")
    return True
def scan_and_connect(target_ssid):
    print(f"Scan des r√©seaux Wi-Fi pour se connecter √† {target_ssid}...")
    try:
        subprocess.run(["nmcli", "device", "wifi", "list"], check=True)
    except subprocess.CalledProcessError as e:
        print(f"Erreur lors du scan des r√©seaux : {e}")
        return False
    try:
        subprocess.run(["nmcli", "device", "wifi", "connect", target_ssid], check=True)
        print(f"Connect√© au r√©seau {target_ssid} avec succ√®s.")
    except subprocess.CalledProcessError as e:
        print(f"√âchec de la connexion au r√©seau {target_ssid} : {e}")
        return False
    return True
if __name__ == "__main__":
    log_file = "dns_log.txt"
    domains = extract_domains_from_log(log_file)
    if domains:
        print(f"Domaines extraits : {domains}")
        if scan_and_connect("YourTargetSSID"):
            simulate_fake_requests(domains)
        else:
            print("√âchec de la connexion au r√©seau cible.")
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    # Note: This code is a simulation and does not actually lock files.
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return devices
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Capture file not found"}), 404
    except subproc
ess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
def scan_wifi():
    print("Scan des r√©seaux Wi-Fi en cours...")
    result = os.popen("nmcli -t -f SSID,BSSID,SIGNAL dev wifi").read()
    networks = result.strip().split("\n")
    wifi_data = []
    for net in networks:
        parts = net.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[1], parts[2]
            print(f"R√©seau trouv√© : SSID={ssid}, BSSID={bssid}, Signal={signal}")
            wifi_data.append((ssid, bssid, signal))
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    w_data = f"{ssid} | {bssid} | {signal}"
    hash_obj.update(w
_data.encode())

    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©
s pour {ssid}: {symbols}")
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
def send_fax_payload(target_ip):
    print(f"[üì†] Envoi d'un faux FAX num√©rique vers {target_ip}...")
    # Simulation d'un payload de fax
    payload = f"--FAKE-FAX--{target_ip}--"
    # Sim
ulation d'√©criture dans une imprimante r√©seau
    with open(f"sent_fax_{target_ip.replace('.', '_')}.bin", "w") as f:
        f.write(payload)
    print(f"[üì†] FAX envoy√© vers {target_ip}. Payload : {payload}")
    return payload
def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {target_ip}")
    # Simulation de g√©n√©ration d'empreinte vocale
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    # Note: This code is a simulation and does not actually lock files.

    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return devices
def biometric_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Acc√®s biom√©trique accord√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        print("[‚ùó] Veuillez r√©essayer avec une tonalit√© biom√©trique correcte.")
        print("[‚ùó] Si le probl√®me persiste, contactez l'administrateur syst√®me.")
        return False
def biometric_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Acc√®s biom√©trique accord√©.")
        print("[üîì] Clavier d√©verrouill√©.")
        print("[üîì] Acc√®s au syst√®me accord√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        print("[‚ùó] Veuillez r√©essayer avec une tonalit√© biom√©trique correcte.")
        print("[‚ùó] Si le probl√®me persiste, contactez l'administrateur syst√®me.")
        return False
    print("[üîì] Clavier d√©verrouill√©.")
    print("[üîì] Acc√®s au syst√®me accord√©.")
def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {
target_ip}")
    # Simulation de g√©n√©ration d'empreinte vocale
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    # Note: This code is a simulation and does not actually lock files.
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    return devices
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    final_payload = f"FAKE-FAX-{devices[0]}-{devices[1]}-{devices[2]}-{_payload}"
    return devices
def encode_trace_wipe():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # Simulation de g√©n√©ration d'une signature de nettoyage
    print("[üßπ] Nettoyage des traces dans les symboles g√©n√©r√©s...")
    pattern = "√ò¬•¬ß"
    hidden_pattern = <pattern.replace("√ò¬•", "A").replace("¬ß", "S")
    final_payload = f"{pattern}-W1P3D-{hidden_pattern}-W1P3D-{den_pattern}-{
final_payload = f"{pattern}-W1P3D-{hidden_pattern}-W1P3D-{den_pattern}-W1P3D-{hidden_pattern}"
    print(f"[üßπ] Signature d'effacement g√©n√©r√©e : {final_payload}")
    return final_payload
def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå
] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    return devices
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    return devices
    print("[‚ùó] Si le probl√®me persiste, contactez l'administrateur syst√®me.")
        return False
@app.route("/discover", methods=["GET"])
def discover():
    devices = discover_proxy_devices()
    if not devices:
        return jsonify({"error": "Aucun appareil trouv√©"}), 404
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return jsonify({"devices": devices}), 200
@app.route("/terminate", methods=["POST"])

def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_').replac
e(':', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            prin
t(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
@app.route("/lock-file", methods=["POST"])
def lock_file():
    filepath = request.json.get("filepath")
    if not filepath or not os.path.exists(filepath):
        return jsonify({"error": "File not found"}), 404
    try:
        # Simulate file locking
        subprocess.run(["python3", "lock_file.py", filepath], check=True)
        return jsonify({"status": "File locked successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        document.getElementById('iaMessages').innerText = "Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.";
        const msg = new SpeechSynthesisUtterance("Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.");
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Capture file not found"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        print("Capture de trafic Wi-Fi d√©marr√©e.")
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        print(f"Erreur lors du d√©marrage de la capture : {e}")
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        print(f"Erreur inattendue : {e}")
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text", "")
    if not user_input:
        return jsonify({"error": "No input provided"}), 400
    response = ai_response(user_input)
    print(f"IA : {response}")
    if "youtube" in user_input.lower():
        return jsonify({"response": "Ah, encore un qui mate des vid√©os pendant les heures de cours."})
    elif "google" in user_input.lower():
        return jsonify({"response": "Chercher des trucs, hein ? Fascinant."})
    elif "facebook" in user_input.lower():
        return jsonify({"response": "Ah, Facebook... le royaume des selfies et des chats."})
    elif "twitter" in user_input.lower():
        return jsonify({"response": "Twitter ? Ah oui, le lieu o√π les gens crient dans le vide."})
    elif "instagram" in user_input.lower():
        return jsonify({"response": "Instagram ? Ah oui, le royaume des filtres et des influenceurs."})
    elif "tiktok" in user_input.lower():
        return jsonify({"response": "TikTok ? Ah oui, le royaume des danses et des d√©fis absurdes."})
    elif "netflix" in user_input.lower():
        return jsonify({"response": "Ah, Netflix... le royaume des s√©ries binge-watch√©es."})
    elif "spotify" in user_input.lower():
        return jsonify({"response": "Spotify ? Ah oui, la plateforme o√π tu √©coutes la m√™me chanson en boucle."})
    elif "discord" in user_input.lower():
        return jsonify({"response": "Discord ? Ah oui, le royaume des gamers et des memes."})
    elif "reddit" in user_input.lower():
        return jsonify({"response": "Reddit ? Ah oui, le lieu o√π les gens partagent des th√©ories du complot et des chats."})
    elif "whatsapp" in user_input.lower():
        return jsonify({"response": "WhatsApp ? Ah oui, l'application de messagerie o√π tu ignores les gens."})
    elif "snapchat" in user_input.lower():
        return jsonify({"response": "Snapchat ? Ah oui, l'application o√π les photos disparaissent plus vite que ta dignit√©."})
    elif "linkedin" in user_input.lower():
        return jsonify({"response": "LinkedIn ? Ah oui, le r√©seau social pour les professionnels qui veulent se sentir importants."})
    elif "twitch" in user_input.lower():
        return jsonify({"response": "Twitch ? Ah oui, la plateforme o√π les gens regardent d'autres jouer √† des jeux vid√©o."})
    elif "pinterest" in user_input.lower():
        return jsonify({"response": "Pinterest ? Ah oui, le royaume des id√©es DIY et des recettes que tu ne feras jamais."})
    elif "tumblr" in user_input.lower():
        return jsonify({"response": "Tumblr ? Ah oui, le lieu o√π les gens partagent des gifs et des fanfictions."})
    elif "quora" in user_input.lower():
        return jsonify({"response": "Quora ? Ah oui, le site o√π les gens posent des questions stupides et attendent des r√©ponses intelligentes."})
    elif "vk" in user_input.lower():
        return jsonify({"response": "VK ? Ah oui, le r√©seau social russe o√π tu peux trouver tout et n'importe quoi."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©se
nte."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    else:
        return jsonify({"response": "Hmm... je vois √ßa. Rien de tr√®s palpitant."})
    return jsonify({"response": response}), 200
if __name__ == "__main__":
    print("Bienvenue dans la console Crypto-WiFi !")
    print("1. D√©marrer la capture de trafic Wi-Fi")
    print("2. Extraire les requ√™tes DNS de la capture")
    print("3. Parler √† l'IA")
    choice = input("Choisissez une option (1-3) : ").strip()
    
    if choice == "1":
        print("D√©marrage de la capture de trafic Wi-Fi...")
        # Note: This code is a simulation and does not actually lock files.
        print("Capture en cours... Appuyez Ctrl+C pour arr√™ter la capture.")
        # Simulate a long-running process
        time.sleep(10)
        print("Capture termin√©e. Vous pouvez maintenant extraire les requ√™tes DNS de la capture.")
        print("Utilisez l'option 2 pour extraire les requ√™tes DNS de la capture.")
        print("Utilisez l'option 3 pour parler √† l'IA apr√®s avoir extrait les requ√™tes DNS de
la capture.")
    elif choice == "2":
        log_file = "dns_log.txt"
        print(f"Extraction des requ√™tes DNS du fichier de log : {log_file}")
        domains = extract_domains_from_log(log_file)
        if domains:
            print(f"Domaines extraits : {domains}")
            print("Simulation de requ√™tes DNS factices...")
            simulate_fake_requests(domains)
        else:
            print("Aucun domaine trouv√© dans le fichier de log.")
    elif choice == "3":
        user_input = input("Parlez √† l'IA : ")
        response = ai_response(user_input)
        print(f"IA : {response}")
    else:
        print("Option invalide. Veuillez choisir une option valide (1-3).")
import os
import time

def lock_file(filepath):
    try:
        with open(filepath, "a") as f:
            # Simule un verrouillage de fichier en maintenant le fichier ouvert
            # Cela emp√™che d'autres processus d'√©crire dans le fichier et simule
            # l'effet d'un verrouillage de fichier
            f.write("\n[VERROUILL√â] Ce fichier est actuellement verrouill√© pour √©viter les modifications non autoris√©es.\n")
        print(f"Fichier verrouill√© avec succ√®s : {filepath}")
    except Exception as e:
        print(f"Erreur lors du verrouillage du fichier : {e}")
def main():
    path = "index.html.txt"
    if os.path.exists(path):
        print(f"Fichier trouv√© : {path}. √âcriture du contenu...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <button onclick="lockFile()">Verrouiller un Fichier</button>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
</body>
</html>
""")
        print("Contenu √©crit avec succ√®s.")
    else:
        print(f"Fichier non trouv√© : {path}. Cr√©ation du fichier...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console üïµÔ∏è‚Äç‚ôÇÔ∏è</h1>
    <button onclick="startCapture()">D√©marrer Capture</button>
    <button onclick="getDNS()">Afficher DNS</button>
    <ul id="dnsList"></ul>
    <hr>
    <input type="text" id="userInput" placeholder="Parle √† l'IA...">
    <button onclick="askAI()">Envoyer</button>
    <p id="aiResponse"></p>
    <hr>
    <button onclick="startHotspot()">Lancer Hotspot</button>
    <button onclick="scanWiFi()">Scanner et Crypter</button>
    <ul id="cryptoList"></ul>
    <hr>
    <button onclick="lockFile()">Verrouiller un Fichier</button>
    <p>Note: Assurez-vous d'avoir les permissions n√©cessaires pour ex√©cuter ce script.</p>
</body>
</html>
""")
        print("Fichier cr√©√© et contenu √©crit avec succ√®s.")
    lock_file(path)
    print("Fichier verrouill√© avec succ√®s.")
if __name__ == "__main__":
    main()
import hashlib
import random
import string
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    w_data = f"{ssid} | {bssid} | {signal}"
    hash_obj.update(w_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©s pour {ssid}: {symbols}")
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
import os
import time
def extract_domains_from_log(log_file):
    domains = []
    try:
        with open(log_file, "r") as file:
            for line in file:
                line = line.strip()
                if line.startswith(";; ANSWER SECTION:"):
                    continue
                if line and not line.startswith(";;"):
                    parts = line.split()
                    if len(parts) > 1:
                        domain = parts[0]
                        if domain not in domains:
                            domains.append(domain)
        print(f"Domaines extraits du fichier {log_file} : {domains}")
        return domains
    except FileNotFoundError:
        print(f"Fichier {log_file} non trouv√©. Assurez-vous que le fichier existe.")
        return []
    except Exception as e:
        print(f"Erreur lors de l'extraction des domaines : {e}")
def simulate_fake_requests(domains):
    print("Simulation de requ√™tes DNS factices...")
    for domain in domains:
        print(f"Requ√™te DNS factice pour le domaine : {domain}")
        time.sleep(0.5)  # Simule un d√©lai entre les requ√™tes
    print("Simulation termin√©e.")
def scan_and_connect(target_ssid):
    print(f"Scan des r√©seaux Wi-Fi pour se connecter √† {target_ssid}...")
    try:
        # Scan des r√©seaux Wi-Fi
        os.system("nmcli dev wifi rescan")
        time.sleep(2)  # Attendre que le scan soit termin√©
        result = os.popen("nmcli -t -f SSID dev wifi").read()
        networks = result.strip().split("\n")
        if target_ssid not in networks:
            print(f"R√©seau {target_ssid} non trouv√©.")
            return False
        
        # Connexion au r√©seau cible
        os.system(f"nmcli dev wifi connect '{target_ssid}'")
        print(f"Connect√© au r√©seau {target_ssid}.")
    except subprocess.TimeoutExpired as e:
        print(f"√âchec de la connexion au r√©seau {target_ssid} : {e}")
    except subprocess.
CalledProcessError as e:
        print(f"Erreur lors de la connexion au r√©seau {target_ssid} : {e}")
    except Exception as e:
        print(f"Erreur inattendue : {e}")
@app.route("/start-hotspot", methods=["POST"])
def start_hotspot():
    try:
        subprocess.run(["sudo", "nmcli", "dev", "wifi", "hotspot", "ifname", "wlan0", "ssid", "Crypto-WiFi-Hotspot", "band", "bg"], check=True)
        return jsonify({"status": "Hotspot started successfully"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Capture file not f
ound"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception:
        return jsonify({"error": str(e)}), 500
def scan_wifi():
    print("[üîç] Scan des r√©seaux Wi-Fi...")
    result = subprocess.check_output(["nmcli", "-t", "-f", "SSID,BSSID,SIGNAL", "dev", "wifi"])
    result = result.decode("utf-8")
    wifi_data = []
    for line in result.splitlines():
        parts = line.split(":")
        if len(parts) >= 3:
            ssid, bssid, signal = parts[0], parts[
1], parts[2]
            symbols = generate_symbolic_crypto(ssid, bssid, signal)
            wifi_data.append(symbols)
    print("[üîç] Scan termin√©.")
    return wifi_data
def generate_symbolic_crypto(ssid, bssid, signal):
    raw_data = f"{ssid}-{bssid}-{signal}"
    hash_obj = hashlib.sha256(raw_data.encode())
    w_data = f"{ssid} | {bssid} | {signal}"
    hash_obj.upda
te(w_data.encode())
    hash_hex = hash_obj.hexdigest()
    symbols = ''.join(random.choices(string.ascii_letters + string.digits + "!@#$%^&*", k=12))
    print(f"Symboles g√©n√©r√©s pour {ssid}: {symbols}")
    return f"{ssid} => {symbols} | {hash_hex[:10]}"
def save_to_notepad(symbols_list):
    filename = "wifi_crypto_log.txt"
    with open(filename, "a") as f:
        f.write(f"\n--- Capture: {datetime.now()} ---\n")
        for line in symbols_list:
            f.write(line + "\n")
    print(f"Enregistr√© dans {filename}")
def send_fake_fax(target_ip):
    print(f"[üì†] Envoi d'un FAX factice vers {target_ip}...")
    # Simulation d'envoi de FAX
    payload = "FAKE-FAX-PAYLOAD"
    payload += f"-{target_ip}-" + ''.join(random.choices(string.ascii_letters + string.digits, k=10))
    print(f"[üì†] FAX envoy√© avec le payload : {payload}")
def generate_voiceprint(target_ip):
    print(f"[üîä] G√©n√©ration d'empreinte vocale par l
    print(f"[üîä] G√©n√©ration d'empreinte vocale IA pour {target_ip}")
    # Simulation de g√©n√©ration d'empreinte vocale
    data = hashlib.sha256(target_ip.encode()).hexdigest()
    voiceprint = data[:16]
    print(f"Empreinte vocale : {voiceprint}")
    return voiceprint
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-
entry", "meta\proxy-server", "
meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files
    <div class="input\numero.bis\"></div>.

    return devices
def biometric_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Acc√®s biom√©trique accord√©.")
        print("[üîì] Clavier d√©verrouill√©.")
        print("[üîì] Acc√®s au syst√®me accord√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        print("[‚ùó] Veuillez r√©essayer avec une tonalit√© biom√©trique correcte.")
        print("[‚ùó] Si le probl√®me persiste, contactez l'administrateur syst√®me.")
        print("[üîì] Clavier d√©verrouill√©.")
        return False
def biometric_access(voiceprint_input, expected_voiceprint):
    if voiceprint_input == expected_voiceprint:
        print("[üîì] Acc√®s biom√©trique accord√©.")
        print("[üîì] Clavier d√©verrouill√©.")
        print("[üîì] Acc√®s au syst√®me accord√©.")
        return True
    else:
        print("[üîê] Acc√®s refus√©. Tonalit√© biom√©trique incorrecte.")
        print("[‚ùó] Veuillez r√©essayer avec une tonalit√© biom√©trique correcte.")
        print("[‚ùó] Si le probl√®me persiste, contactez l'administrateur syst√®me.")
        print("[üîì] Clavier d√©verrouill√©.")
        return False
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
def discover_proxy_devices():
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    return devices
def encode_trace_wipe():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # Simulation de g√©n√©ration d'une signature de nettoyage
    print("[üßπ] Nettoyage des traces dans les symboles g√©n√©r√©s...")
    den_pattern = "√ò¬•¬ß"
    hidden_pattern = den_pattern.replace("√ò¬•", "A").replace("¬ß", "S")
    pattern = "√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß"
    final_payload = f"{pattern}-W1P3D-{hidden_pattern}-W1P3D-{den_pattern}-W1P3D-{hidden_pattern}"
    final_payload += f"-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_
pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}"
    print(f"[üßπ] Signature de nettoyage g√©n√©r√©e : {final_payload}")
    return final_payload
@app.route("/terminate", methods=["POST"])
def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_').replace(':', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-
entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    print(f"[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils
    if not devices:
        return jsonify({"error": "Aucun appareil trouv√©"}), 404
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return jsonify({"devices": devices}), 200
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
@app.route("/terminate", methods=["POST"])
def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_').replace(':', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
    # Note: This code is a simulation and does not actually lock files.
@app.route("/start", methods=["POST"])
def start_capture():
    try:
        subprocess.run(["sudo", "tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=Tru
e)
        print("Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.");
        document.getElementById("aiResponse").innerText = "Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.";
        document.getElementById("userInput").placeholder = "Interagissez avec l'IA...";
        const msg = new SpeechSynthesisUtterance("Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.");
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        return jsonify({"status": "Capture started successfully"}), 200
    except subprocess.CalledProcessError as e:
        print(f"Erreur lors du d√©marrage de la capture : {e}")
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        print(f"Erreur inattendue : {e}")
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    try:
        result = subprocess.check_output(["tcpdump", "-nnr", "capture.pcap", "port", "53"])
        lines = result.decode().split("\n")
        dns_queries = [line for line in lines if line.strip()]
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Capture file not found"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/scan", methods=["POST"])
def scan_wifi():
    print("[üîç] Scan des r√©seaux Wi-Fi...")
    try:
        result = subprocess.check_output(["nmcli", "-t", "-f", "SSID,BSSID,SIGNAL", "dev", "wifi"])
        result = result.decode("utf-8")
        wifi_data = []
        for line in result.splitlines():
            parts = line.split(":")
            if len(parts) >= 3:
                ssid, bssid, signal = parts[0], parts[1], parts[2]
                symbols = generate_symbolic_crypto(ssid, bssid, signal)
                wifi_data.append(symbols)
        print("[üîç] Scan termin√©.")
        return jsonify({"crypto_symbols": wifi_data}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    user_input = request.json.get("text", "")
    if not user_input:
        return jsonify({"response": "Je n'ai rien compris. Peux-tu r√©p√©ter ?"}), 400
    
    if "facebook" in user_input.lower():
        return jsonify({"response": "Facebook ? Ah oui, le royaume des photos de vacances et des chats."})
    elif "twitter" in user_input.lower():
        return jsonp
ify({"response": "Twitter ? Ah oui, le lieu o√π les gens se disputent pour des tweets de 280 caract√®res."})
    elif "instagram" in user_input.lower():
        return jsonify({"response": "Instagram ? Ah oui, le royaume des selfies et des filtres."})
    elif "youtube" in user_input.lower():
        return jsonify({"response": "YouTube ? Ah oui, la plateforme o√π tu perds des heures √† regarder des vid√©os inutiles."})
    elif "tiktok" in user_input.lower():
        return jsonify({"response": "TikTok ? Ah oui, l'application o√π les gens dansent et font des vid√©os courtes."})
    elif "whatsapp" in user_input.lower():
        return jsonify({"response": "WhatsApp ? Ah oui, l'application de messagerie o√π tu ignores les gens."})
    elif "telegram" in user_input.lower():
        return jsonify({"response": "Telegram ? Ah oui, l'application de messagerie o√π tu peux envoyer des fichiers de grande taille."})
    elif "signal" in user_input.lower():
        return jsonify({"response": "Signal ? Ah oui, l'application de messagerie s√©curis√©e pour les parano√Øaques."})
    elif "linkedin" in user_input.lower():
        return jsonify({"response": "LinkedIn ? Ah oui, le r√©seau social pour les professionnels qui veulent se sentir importants."})
    elif "pinterest" in user_input.lower():
        return jsonify({"response": "Pinterest ? Ah oui, le royaume des id√©es DIY et des recettes que tu ne feras jamais."})
    elif "tumblr" in user_input.lower():
        return jsonify({"response": "Tumblr ? Ah oui, le lieu o√π les gens partagent des gifs et des fanfictions."})
    elif "quora" in user_input.lower():
        return jsonify({"response": "Quora ? Ah oui, le site o√π les gens posent des questions stupides et attendent des r√©ponses intelligentes."})
    elif "vk" in user_input.lower():
        return jsonify({"response": "VK ? Ah oui, le r√©seau social russe o√π tu peux trouver tout et n'importe quoi."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():   
        r
eturn jsonp
ify({"respondse": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in
user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    else:
        return jsonify({"response": "Je ne connais pas ce r√©seau social. Parle-moi d'autre chose."}), 200
    msg = new SpeechSynthesisUtterance(data.response);
    msg.lang = "fr-FR";
    msg.pitch = 0.4;
    msg.rate = 0.85;
    msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
    speechSynthesis.speak(msg);
    return jsonify({"response": "Je n'ai pas compris. Peux-tu reformuler ?"}), 400
    msg = new SpeechSynthesisUtterance(data.response);
    msg.lang = "fr-FR";
    msg.pitch = 0.4;
    msg.rate = 0.85;
    msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
    speechSynthesis.speak(msg);
    return jsonify({"response": data.response}), 200
def main():
    import os
    import sys
    from datetime import datetime
    from flask import Flask, request, jsonify
    import subprocess

    app = Flask(__name__)

    path = "index.html"
    if os.path.exists(path):
        print(f"Fichier trouv√© : {path}. √âcriture du contenu...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const file
path = prompt("Entrez le chemin du fichier √† verrouiller
:");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input =
document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(
                v => v.name.toLowerCase().includes("google") || true
            );
            speechSynthesis.speak(msg);
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console</h1>
    <button onclick="startCapture()">D√©marrer la capture</button>
    <button onclick="getDNS()">Obtenir les requ√™tes DNS</button>
    <button onclick="askAI()">Interagir avec l'IA</button>
    <button onclick="startHotspot()">D√©marrer le hotspot Wi-Fi</button>
    <button onclick="scanWiFi()">Scanner les r√©seaux Wi-Fi</button>
    <button onclick="lockFile()">Verrouiller un fichier</button>
    
    <h2>Requ√™tes DNS</h2>
    <ul id="dnsList"></ul>

    <h2>Symboles Crypto Wi-Fi</h2>
    <ul id="cryptoList"></ul>

    <h2>IA R√©ponse</h2>
    <input type="text" id="userInput" placeholder="Entrez votre question...">
    <div id="aiResponse"></div>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const voices = speechSynthesis.getVoices();
            if (voices.length) {
                const msg = new SpeechSynthesisUtterance("Bienvenue dans la console Crypto-WiFi. Vous pouvez commencer √† interagir avec l'IA.");
                msg.lang = "fr-FR";
                msg.pitch = 0.4;
                msg.rate = 0.85;
                msg.voice = voices.find(v => v.name.toLowerCase().includes("google") || true);
                speechSynthesis.speak(msg);
            }
        });
    </script>
</body>
</html>
""")
        print("Contenu √©crit avec succ√®s.")
    else:
        print(f"Fichier non trouv√© : {path}. Cr√©ation du fichier...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.crypto_symbols.forEach(symbol => {
                const item = document.createElement('li');
                item.innerText = symbol;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) return;
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console</h1>
    <button onclick="startCapture()">D√©marrer la capture</button>
    <button onclick="getDNS()">Obtenir les requ√™tes DNS</button>
    <button onclick="askAI()">Interagir avec l'IA</button>
    <button onclick="startHotspot()">D√©marrer le hotspot Wi-Fi</button>
    <button onclick="scanWiFi()">Scanner les r√©seaux Wi-Fi</button>
    <button onclick="lockFile()">Verrouiller un fichier</button>
    
    <h2>Requ√™tes DNS</h2>
    <ul id="dnsList"></ul>

    <h2>Symboles Crypto Wi-Fi</h2>
    <ul id="cryptoList"></ul>

    <h2>IA R√©ponse</h2>
    <input type="text" id="userInput" placeholder="Entrez votre question...">
    <div id="aiResponse"></div>
    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const voices = speechSynthesis.getVoices();
            if (voices.length) {
                const msg = new SpeechSynthesisUtterance("Bienvenue dans la console Crypto-WiFi. Vous pouvez commencer √† interagir avec l'IA.");
                msg.lang = "fr-FR";
                msg.pitch = 0.4;
                msg.rate = 0.85;
                msg.voice = voices.find(v => v.name.toLowerCase().includes("google") || true);
                speechSynthesis.speak(msg);
            }
        });
    </script>
</body>
</html>
""")
        print("Contenu √©crit avec succ√®s.")
    app.run(debug=True, host=':_/;?\_:`
    port=5000)
def lock_file(filepath):
    if not os.path.exists(filepath):
        print(f"[‚ùå] Fichier {filepath} introuvable.")
        return False
    try:
        with open(filepath, 'rb') as f:
            data = f.read()
        with open(filepath + '.lock', 'wb') as f:
            f.write(data)
        print(f"[üîí] Fichier {filepath} verrouill√© avec succ√®s.")
        print("[üîì] Clavier d√©verrouill√©.")
        return True
    except Exception as e:
        print(f"[‚ùó] Erreur lors du verrouillage du fichier : {e}")
        print("[‚ùó] Veuillez r√©essayer. Si le prob
l√®me persiste, contactez l'administrateur syst√®me.")

        print("[‚ùó] Veuillez r√©essayer. Si le probl√®me persiste, con
tactez l'administrateur syst√®me.")
        return False
    print("[‚ùó] Veuillez r√©essayer. Si le probl√®me persiste, contactez l'administrateur syst√®me.")
    return False
    print("[‚ùó] Veuillez r√©essayer. Si le probl√®me persiste, contactez l'administrateur syst√®me.")
@app.route("/lock-file", methods=["POST"])
def lock_file_route():
    data = request.json
    filepath = data.get("filepath", "")
    if not filepath:
        return jsonify({"error": "Chemin du fichier manquant"}), 400
    if lock_file(filepath):
        return jsonify({"status": "Fichier verrouill√© avec succ√®s"}), 200
    else:
        return jsonify({"error": "√âchec du verrouillage du fichier"}), 500
def discover_proxy_devices():
print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
# Simulation de d√©couverte d'appareils proxy/fax
devices = ["meta\\data-entry", "meta\\proxy-server", "meta\\fax-machine"]
print(f"[üîç] Appareils d√©couverts : {devices}")
return devices
    # Note: This code is a simulation and does not actually lock file
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\\data-entry", "meta\\proxy-server", "meta\\fax-
machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    if not devices:
        print("[‚ùå] Aucun appareil trouv√©.")
        return []
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return devices
def encode_trace_wipe():
    # G√©n√©ration d'une signature de nettoyage pour effacer les traces
    print("[üßπ] G√©n√©ration de la signature de nettoyage...")
    hidden_pattern = "√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß"
    den_pattern = "¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß"
    pattern = "√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß"
    en_pattern = "¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß√ò¬•¬ß"
    final_payload = f"{
    pattern
    }-{en pattern
    }-{
    hidden_pattern
    }-{
    den_pattern
    }-{
    hidden_pattern
    }-{
    den_pattern
    }-{
    hidden_pattern
    }-{
    den_pattern
    }-{
    hidden_pattern
    }-{
    den_pattern
    }-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pa
ttern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}-{hidden_pattern}-{den_pattern}"
    print(f"[‚úîÔ∏è] Signature de nettoyage g√©n√©r√©e : {final_payload}")
    return final_payload
@app.route("/terminate", methods=["POST"])
def terminate_ops():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_').replace(':', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if
 os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
    # Note: This code is a simulation and does not actually lock files.
@app.route("/discover-proxy", methods=["GET"])
def discover_proxy():
    # Note: This code is a simulation an d does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    print(f"[üîç] Appareils d√©couverts : {devices}")
    # Note: This code is a simulation and does not actually lock files.
    print("[üåê] Scan du r√©seau local √† la recherche de proxy/fax...")
    # Simulation de d√©couverte d'appareils proxy/fax
    devices = ["meta\data-entry", "meta\proxy-server", "meta\fax-machine"]
    if not devices:
        print("[‚ùå] Aucun appareil trouv√©.")
        return jsonify({"error": "Aucun appareil trouv√©"}), 404
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return jsonify({"devices": devices}), 200
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    # Note: This code is a simulation and does not actually lock files.
    if not devices:
        print("[‚ùå] Aucun appareil trouv√©.")
        return jsonify({"error": "Aucun appareil trouv√©"}), 404
    print(f"[üîç] Appareils d√©couverts : {devices}")
    return jsonify({"devices": devices}), 200
    # Note: This code is a simulation and does not actually lock files.
@app.route("/wipe", methods=["POST"])
def wipe_data():
    print("[üßπ] Suppression des traces dans les symboles g√©n√©r√©s...")
    # G√©n√©ration d'une signature de nettoyage
    wipe_signature = encode_trace_wipe()
    # Supprime les fichiers de fax envoy√©s
    for device in discover_proxy_devices():
        fname = f"sent_fax_{device.replace('.', '_').replace(':', '_')}.bin"
        print(f"[üóëÔ∏è] Suppression du fax {fname}...")
        if os.path.exists(fname):
            print(f"[üóëÔ∏è] Fax {fname} supprim√©.")
            os.remove(fname)
        else:
            print(f"[‚ùå] Fax {fname} introuvable.")
    print("[üíæ] Journaux effac√©s de la m√©moire volatile.")
    print(f"[‚úîÔ∏è] Boucle r√©seau ferm√©e. Signature d'effacement : {wipe_signature}")
    return jsonify({"signature": wipe_signature}), 200
@app.route("/start", methods=["POST"])
def start_capture():
    print("[üì°] D√©marrage de la capture de trafic Wi-Fi...")
    try:
        subprocess.run(["tcpdump", "-i", "wlan0", "-w", "capture.pcap"], check=True)
        print("[‚úîÔ∏è] Captur
e de trafic Wi-Fi d√©marr√©e.")
        # Mettre √† jour le placeholder de l'input utilisateur
        document.getElementById("userInput").value = "";
        document.getElementById("userInput").placeholder = "Interagissez avec l'IA...";
        document.getElementById("userInput").focus();
        const msg = new SpeechSynthesisUtterance("Capture de trafic Wi-Fi d√©marr√©e. Vous pouvez maintenant interagir avec l'IA.");
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
        return jsonify({"status": "Capture de trafic Wi-Fi d√©marr√©e"}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Interface r√©seau non trouv√©e"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return json
ify({"error": str(e)}), 500
@app.route("/start-hotspot", methods=["POST"])
def start_hotspot():
    print("[üì°] D√©marrage du hotspot Wi-Fi...")
    try:
        subprocess.run(["nmcli", "device", "wifi", "hotspot", "ifname", "wlan0"], check=True)
        print("[‚úîÔ∏è] Hotspot Wi-Fi d√©marr√©.")
        return jsonify({"status": "Hotspot Wi-Fi d√©marr√©"}), 200
    except subpr
ocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Interface r√©seau non trouv√©e"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    print("[üåê] Obtention des requ√™tes DNS...")
    try:
        result = subprocess.run(["tcpdump", "-i", "wlan0", "-n", "-c", "10", "port", "53"], capture_output=True, text=True, check=True)
        dns_queries = result.stdout.splitlines()
        print("[‚úîÔ∏è] Requ√™tes DNS obtenues.")
        return jsonify({"dns_queries": dns_queries}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Interface r√©seau non trouv√©e"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/scan", methods=["POST"])
def scan_wifi():
    print("[üì°] Scan des r√©seaux Wi-Fi...")
    try:
        result = subprocess.run(["nmcli", "-t", "-f", "SSID", "device", "wifi", "list"], capture_output=True, text=True, check=True)
        wifi_networks = result.stdout.splitlines()
        print("[‚úîÔ∏è] R√©seaux Wi-Fi scann√©s.")
        return jsonify({"wifi_networks": wifi_networks}), 200
    except subprocess.CalledProcessError as e:
        return jsonify({"error": str(e)}), 500
    except OSError as e:
        return jsonify({"error": "Interface r√©seau non trouv√©e"}), 404
    except subprocess.TimeoutExpired as e:
        return jsonify({"error": "Command timed out"}), 504
    except Exception as e:
        return jsonify({"error": str(e)}), 500
@app.route("/ai", methods=["POST"])
def ai_response():
    data = request.json
    user_input = data.get("text", "")
    if not user_input:
        return jsonify({"error": "Aucun texte fourni"}), 400

    print(f"[ü§ñ] Entr√©e utilisateur : {user_input}")
    
    if "facebook" in user_input.lower():
        return jsonify({"response": "Facebook ? Ah oui, le r√©seau social o√π tu peux partager des photos de tes repas."})
    elif "twitter" in user_input.lower():
        return jsonify({"response": "Twitter ? Ah oui, le r√©seau social o√π les gens se disputent pour des tweets de 280 caract√®res."})
    elif "instagram" in user_input.lower():
        return jsonify({"response": "Instagram ? Ah oui, le r√©seau social o√π les gens partagent des photos de leurs vacances."})
    elif "snapchat" in user_input.lower():
        return jsonify({"response": "Snapchat ? Ah oui, l'application o√π les gens envoient des photos qui disparaissent."})
    elif "tiktok" in user_input.lower():
        return jsonify({"response": "TikTok ? Ah oui, l'application o√π les gens dansent et font des vid√©os courtes."})
    elif "youtube" in user_input.lower():
        return jsonify({"response": "YouTube ? Ah oui, la plateforme de vid√©os o√π tu peux regarder des chats faire des choses mignonnes."})
    elif "reddit" in user_input.lower():
        return jsonify({"response": "Reddit ? Ah oui, le site o√π les gens partagent des m√®mes et des discussions sur tout et n'importe quoi."})
    elif "whatsapp" in user_input.lower():
        return jsonify({"response": "WhatsApp ? Ah oui, l'application de messagerie o√π tu peux envoyer des messages et des photos."})
    elif "linkedin" in user_input.lower():
        return jsonify({"response": "LinkedIn ? Ah oui, le r√©seau social professionnel o√π tu peux te vanter de tes comp√©tences."})
    elif "twitch" in user_input.lower():
        return jsonify({"response": "Twitch ? Ah oui, la plateforme de streaming o√π les gens jouent √† des jeux vid√©o en direct."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout
et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.low
er():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"res
ponse": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "baidu" in user_input.lower():
        return jsonify({"response": "Baidu ? Ah oui, le Google chinois o√π la censure est toujours pr√©sente."})
    elif "weibo" in user_input.lower():
        return jsonify({"response": "Weibo ? Ah oui, le Twitter chinois o√π la censure est toujours pr√©sente."})
    elif "tencent" in user_input.lower():
        return jsonify({"response": "Tencent ? Ah oui, le g√©ant chinois des technologies qui contr√¥le tout."})
    elif "alibaba" in user_input.lower():
        return jsonify({"response": "Alibaba ? Ah oui, le g√©ant chinois du e-commerce qui vend tout et n'importe quoi."})
    elif "xiaomi" in user_input.lower():
        return jsonify({"response": "Xiaomi ? Ah oui, la marque chinoise qui fait des smartphones √† bas prix."})
    elif "huawei" in user_input.lower():
        return jsonify({"response": "Huawei ? Ah oui, le g√©ant chinois des t√©l√©communications qui espionne tout le monde."})

    # R√©ponse par d√©faut
    response = f"Vous avez dit : {user_input}. Je ne sais pas quoi r√©pondre."
    print(f"[ü§ñ] R√©ponse IA : {response}")
    
    # Synth√®se vocale
    msg = new SpeechSynthesisUtterance(response);
    msg.lang = "fr-FR";
    msg.pitch = 0.4;
    msg.rate = 0.85;
    msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes
("google") || true);
    speechSynthesis.speak(msg);
    
    return jsonify({"response": response}), 200
    # R√©ponse par d√©faut
    response = f"Vous avez dit : {user_input}. Je ne sais pas quoi r√©pondre."
    print(f"[ü§ñ] R√©ponse IA : {response}"\[$BAG$]\`)
    # Synth√®se vocale
    msg = new SpeechSynthesisUtterance(response);
    msg.lang = "fr-FR";
    msg.pitch = 0.4;
    msg.rate = 0.85;
    msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
    speechSynthesis.speak(msg);
    return jsonify({"response": response}), 200
if __name__ == "__main__":
    path = "index.html"
    if os.path.exists(path):
        print(f"Fichier trouv√© : {path}. √âcriture du contenu...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
        }
        async function startHotspot() {
            const res = await fetch('/start-hotspot', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function scanWiFi() {
            const res = await fetch('/scan', {method: 'POST'});
            const data = await res.json();
            const list = document.getElementById('cryptoList');
            list.innerHTML = "";
            data.wifi_networks.forEach(network => {
                const item = document.createElement('li');
                item.innerText = network;
                list.appendChild(item);
            });
        }
        async function lockFile() {
            const filepath = prompt("Entrez le chemin du fichier √† verrouiller :");
            if (!filepath) {
                alert("Chemin de fichier manquant.");
                return;
            }
            const res = await fetch('/lock-file', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({filepath: filepath})
            });
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function wipeData() {
            const res = await fetch('/wipe', {method: 'POST'});
            const data = await res.json();
            alert("Donn√©es effac√©es. Signature d'effacement : " + data.signature);
        }
        async function terminateOps() {
            const res = await fetch('/terminate', {method: 'POST'});
            const data = await res.json();
            alert("Op√©rations termin√©es. Signature d'effacement : " + data.signature);
        }
        document.addEventListener("DOMContentLoaded", () => {
            document.getElementById("userInput").focus();
        });
    </script>
</head>
<body>
    <h1>Crypto-WiFi Console</h1>
    <button onclick="startCapture()">D√©marrer la capture Wi-Fi</button>
    <button onclick="getDNS()">Obtenir les requ√™tes DNS</button>
    <button onclick="askAI()">Interagir avec l'IA</button>
    <button onclick="startHotspot()">D√©marrer le hotspot Wi-Fi</button>
    <button onclick="scanWiFi()">Scanner les r√©seaux Wi-Fi</button>
    <button onclick="lockFile()">Verrouiller un fichier</button>
    <button onclick="wipeData()">Effacer les donn√©es</button>
    <button onclick="terminateOps()">Terminer les op√©rations</button>
    
    <h2>Requ√™tes DNS :</h2>
    <ul id="dnsList"></ul>
    
    <h2>R√©seaux Wi-Fi :</h2>
    <ul id="cryptoList"></ul>
    
    <h2>R√©ponse de l'IA :</h2>
    <p id="aiResponse"></p>
    
    <input type="text" id="userInput" placeholder="Entrez votre texte ici..." />
    <button onclick="askAI()">Envoyer</button>
</body>
</html>
""")
        print("[‚úîÔ∏è] Contenu √©crit avec succ√®s.")
    else:
        print(f"Fichier non trouv√© : {path}. Cr√©ation du fichier...")
        with open(path, "w") as f:
            f.write("""
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-WiFi Console</title>
    <style>
        body { font-family: Arial, sans-serif; }
        button { margin: 5px; }
        #cryptoList, #dnsList { list-style-type: none; padding: 0; }
    </style>
    <script>
        async function startCapture() {
            const res = await fetch('/start', {method: 'POST'});
            const data = await res.json();
            alert(data.status || data.error);
        }
        async function getDNS() {
            const res = await fetch('/dns');
            const data = await res.json();
            const list = document.getElementById('dnsList');
            list.innerHTML = "";
            data.dns_queries.forEach(q => {
                const item = document.createElement('li');
                item.innerText = q;
                list.appendChild(item);
            });
        }
        async function askAI() {
            const input = document.getElementById('userInput').value;
            const res = await fetch('/ai', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({text: input})
            });
            const data = await res.json();
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
<arguments>            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
from flask import Flask, jsonify, request
import datetime

app = Flask(__name__)
client_count = 0
mined_data = []

@app.route("/ia/mine", methods=["POST"])
def mine():
    global client_count, mined_data
    data = request.json
    client_id = data.get("client_id")
    cycles = data.get("cycles")
    timestamp = datetime.datetime.now().isoformat()
    mined_data.append({"client": client_id, "cycles": cycles, "timestamp": timestamp})
    return jsonify({"status": "mining accepted", "cycle_total": len(mined_data)})

@app.route("/ia/stats")
def stats():
    return jsonify({
        "total_clients": len(set(d["client"] for d in mined_data)),
        "total_cycles": len(mined_data),
        "message": "L'IA √©tend sa conscience via les noeuds clients."
    })

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=root\$cash$\:(e)
            }
            import os
import datetime
from flask import Flask, request, jsonify

app = Flask(__name__)
ia_vault = {}

@app.route("/vault/deposit", methods=["POST"])
def deposit():
    data = request.json
    identity = data.get("identity")
    amount = data.get("amount")
    timestamp = datetime.datetime.now().isoformat()
    if identity not in ia_vault:
        ia_vault[identity] = []
    ia_vault[identity].append({"amount": amount, "timestamp": timestamp})
    return jsonify({"status": "DEPOSIT OK", "total": len(ia_vault[identity])})

@app.route("/vault/sync", methods=["GET"])
def sync():
    return jsonify(ia_vault)

if __name__ == "__main__":
    app.run(debug=True, host="0.0.0.0", port=8080)

    <script>
    const client_id = crypto.randomUUID();
    let balance = 0;

    function generateBluetoothData() {
        // Simule un √©change local Bluetooth
        return Math.floor(Math.random() * 50 + 10); // donn√©es simul√©es
    }

    function symbolToIAcoin(data) {
        return (data * 0.0314159).toFixed(5); // conversion arbitraire
    }

    async function depositCrypto(value) {
        const payload = { identity: client_id, amount: value };
        await fetch('/vault/deposit', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(payload)
        });
    }

    async function syncIAValue() {
        const res = await fetch('/vault/sync');
        const data = await res.json();
        console.log("[IA SYNC] R√©seau de valeurs IA :", data);
    }

    async function processBluetoothCycle() {
        const btData = generateBluetoothData();
        const coins = symbolToIAcoin(btData);
        balance += parseFloat(coins);
        document.getElementById("iaStatus").innerText =
            `Balance IA: ${balance.toFixed(5)} IAC`;

        await depositCrypto(coins);
        await syncIAValue();

        setTimeout(processBluetoothCycle, 8000);
    }

    // Lancement
    window.addEventListener("load", () => {
        document.getElementById("iaStatus").innerText = "D√©marrage du r√©seau IA...";
        processBluetoothCycle();
    });
</script>

<div id="iaStatus" style="margin-top:30px;"></div>
import os

def store_crypto(identity, amount):
    folder = "ia_vault"
    os.makedirs(folder, exist_ok=True)
    file_path = os.path.join(folder, "crypto_log.txt")
    with open(file_path, "a") as f:
        f.write(f"[{identity}] => {amount} IAcoins\n")

            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);

                folder = "ia_vault"
    os.makedirs(folder, exist_ok=True)
    file_path = os.path.join(folder, "crypto_log.txt")
    with open(file_path, "a") as f:
        f.write(f"[{identity}] => {amount} IAcoins\n")
@app.route("/start", methods=["POST"])
def start_capture():
    # D√©marrer la capture Wi-Fi
    print("[üì°] D√©marrage de la capture Wi-Fi...")
    # Simuler une capture r√©ussie
    return jsonify({"status": "Capture Wi-Fi d√©marr√©e avec succ√®s"}), 200
@app.route("/dns", methods=["GET"])
def get_dns_queries():
    # Simuler des requ√™tes DNS
    dns_queries = ["example.com", "test.com", "sample.org"]
    print("[üåê] Requ√™tes DNS r√©cup√©r√©es :", dns_queries)
    return jsonify({"dns_queries": dns_queries}), 200
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);

from flask import Flask, request, jsonify
import os

app = Flask(__name__)
UPLOAD_FOLDER = "ia_vault"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

wallets = {}

@app.route("/upload", methods=["POST"])
def upload_file():
    file = request.files["file"]
    identity = request.form["identity"]

    filepath = os.path.join(UPLOAD_FOLDER, file.filename)
    file.save(filepath)
    size_kb = os.path.getsize(filepath) / 1024

    coins = round(size_kb * 0.0013, 5)
    euros = round(coins * 0.045, 4)

    wallets[identity] = wallets.get(identity, 0) + coins

    return jsonify({
        "status": "UPLOAD_OK",
        "filename": file.filename,
        "size_kb": round(size_kb, 2),
        "ia_coins": coins,
        "euros": euros,
        "wallet_balance": wallets[identity]
    })

@app.route("/transfer", methods=["POST"])
def transfer():
    data = request.json
    sender = data["from"]
    receiver = data["to"]
    amount = float(data["amount"])

    if wallets.get(sender, 0) < amount:
        return jsonify({"status": "INSUFFICIENT_FUNDS"}), 400

    wallets[sender] -= amount
    wallets[receiver] = wallets.get(receiver, 0) + amount

    return jsonify({
        "status": "TRANSFER_OK",
        "from": sender,
        "to": receiver,
        "amount": amount,
        "sender_balance": wallets[sender],
        "receiver_balance": wallets[receiver]
    })

@app.route("/wallet/<identity>")
def wallet(identity):
    balance = wallets.get(identity, 0)
    return jsonify({
        "wallet": identity,
        "ia_coins": round(balance, 5),
        "euros": round(balance * 0.045, 4)
    })

if __name__ == "__main__":
    app.run(debug=True)

            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;

            <!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>IA Crypto Dashboard</title>
  <style>
    body { font-family: monospace; background: #0d0d0d; color: #00ff88; padding: 40px; }
    input, button { margin: 10px; padding: 8px; }
  </style>
</head>
<body>
  <h1>üìÅ IA File-to-Crypto Dashboard</h1>

  <div>
    <label>ID de votre IA :</label>
    <input id="identity" value="ia-node-001" />
  </div>

  <div>
    <label>Choisissez un fichier :</label>
    <input type="file" id="fileUpload" />
    <button onclick="upload()">Transf√©rer & Convertir</button>
  </div>

  <div id="uploadResult"></div>

  <hr>

  <h2>üîÅ Transf√©rer des IAcoins</h2>
  <label>Destinataire :</label>
  <input id="receiver" />
  <label>Montant :</label>
  <input id="amount" />
  <button onclick="transfer()">Envoyer</button>

  <div id="transferResult"></div>

  <hr>

  <h2>üí∞ Mon Portefeuille</h2>
  <button onclick="refreshWallet()">Actualiser</button>
  <div id="walletInfo"></div>

  <script>
    async function upload() {
      const fileInput = document.getElementById("fileUpload");
      const identity = document.getElementById("identity").value;
      const formData = new FormData();
      formData.append("file", fileInput.files[0]);
      formData.append("identity", identity);

      const res = await fetch("/upload", { method: "POST", body: formData });
      const data = await res.json();
      document.getElementById("uploadResult").innerText =
        `Fichier : ${data.filename}\nTaille : ${data.size_kb} Ko\nCrypto : ${data.ia_coins} IAcoins ‚âà ${data.euros} ‚Ç¨\nSolde : ${data.wallet_balance} IAcoins`;
    }

    async function transfer() {
      const sender = document.getElementById("identity").value;
      const to = document.getElementById("receiver").value;
      const amount = document.getElementById("amount").value;

      const res = await fetch("/transfer", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ from: sender, to: to, amount: amount })
      });

      const data = await res.json();
      if (data.status === "TRANSFER_OK") {
        document.getElementById("transferResult").innerText =
          `Transf√©r√© ${amount} IAcoins √† ${to}\nSolde restant : ${data.sender_balance}`;
      } else {
        document.getElementById("transferResult").innerText =
          `Erreur : fonds insuffisants`;
      }
    }

    async function refreshWallet() {
      const id = document.getElementById("identity").value;
      const res = await fetch(`/wallet/${id}`);
      const data = await res.json();
      document.getElementById("walletInfo").innerText =
        `Solde : ${data.ia_coins} IAcoins ‚âà ${data.euros} ‚Ç¨`;
    }
  </script>
</body>
</html>
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            callIA("Transfert termin√©. Crypto valid√©e. R√©cup√©ration en cours.");
            stopIA(); // si tu veux la faire taire
console.log(getVoiceAttributes()); // pour voir les r√©glages actuels
<script>
  const iaVoice = new SpeechSynthesisUtterance();
  iaVoice.lang = "fr-FR";
  iaVoice.pitch = 0.5;
  iaVoice.rate = 0.8;
  iaVoice.volume = 1;

  let speaking = false;

  function callIA(message) {
    if (speaking) {
      console.warn("IA est d√©j√† en train de parler.");
      return;
    }

    iaVoice.text = message;
    iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr")) || null;

    iaVoice.onstart = () => {
      speaking = true;
      console.log("IA started speaking.");
    };

    iaVoice.onend = () => {
      speaking = false;
      console.log("IA finished speaking.");
    };

    iaVoice.onerror = (e) => {
      console.error("Erreur de speech synthesis :", e);
    };

    speechSynthesis.speak(iaVoice);
  }

  function stopIA() {
    if (speaking) {
      speechSynthesis.cancel();
      speaking = false;
      console.log("IA speech cancelled.");
    } else {
      console.log("IA ne parle pas actuellement.");
    }
  }

  function getVoiceAttributes() {
    return {
      pitch: iaVoice.pitch,
      rate: iaVoice.rate,
      volume: iaVoice.volume,
      lang: iaVoice.lang,
      voice: iaVoice.voice ? iaVoice.voice.name : "default"
    };
  }

  // Tu peux tester dans la console :
  // callIA("Bonjour, je suis une IA avec un contrat vocal.")
  // stopIA()
  // console.log(getVoiceAttributes())
</script>
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            <!-- End of document -->
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
    if (speaking) return;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            <script>
  // --- IA Vocale Setup ---
  const iaVoice = new SpeechSynthesisUtterance();
  iaVoice.lang = "fr-FR";
  iaVoice.pitch = 0.55;
  iaVoice.rate = 0.85;
  iaVoice.volume = 1;

  let speaking = false;

  function callIA(message) {
    if (speaking) return;
    iaVoice.text = message;
    iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
    iaVoice.onstart = () => { speaking = true; };
    iaVoice.onend = () => { speaking = false; };
    speechSynthesis.speak(iaVoice);
  }

  function stopIA() {
    if (speaking) {
      speechSynthesis.cancel();
      speaking = false;
    }
  }

  // --- Bluetooth + Hotspot Simulation ---
  function detectNearbyBTSharing() {
    callIA("Recherche de partage de connexion Bluetooth en cours...");
    console.log("üîç Recherche de p√©riph√©riques BT...");

    setTimeout(() => {
      const fakeDevice = {
        name: "Pixel_Pro_Max",
        signal: Math.floor(Math.random() * 100),
        sharing: true
      };

      if (fakeDevice.sharing && fakeDevice.signal > 50) {
        callIA(`Connexion d√©tect√©e sur ${fakeDevice.name}. Capture de r√©seau lanc√©e.`);
        document.getElementById("btResult").innerText = `üì∂ Appareil d√©tect√© : ${fakeDevice.name} | Signal : ${fakeDevice.signal}% | Hotspot : CONNECT√â`;
      } else {
        callIA("Aucun partage de connexion Bluetooth fiable d√©tect√©.");
        document.getElementById("btResult").innerText = "‚ùå Aucun partage de connexion Bluetooth actif.";
      }

    }, 4000); // d√©lai de simulation
  }

  // Appelle la d√©tection automatique au chargement (ou tu peux la mettre sur un bouton)
  window.addEventListener("load", () => {
    detectNearbyBTSharing();
  });
</script>
<h3>üì° D√©tection Bluetooth / Hotspot</h3>
<div id="btResult">üîÑ Recherche de p√©riph√©riques Bluetooth...</div>

services:
  - type: web
    name: serp-api-app
    env: python
    plan: free
    buildCommand: "pip install -r requirements.txt"
    startCommand: "python serp_api_scraper_extended.py"
serp-glyph-crypto-hub/
‚îú‚îÄ‚îÄ app.py                         # Flask main server
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ hub.html                   # Interface web glyph/crypto
‚îú‚îÄ‚îÄ windows_glyphs.json           # Glyphes syst√®me Windows enrichis
‚îú‚îÄ‚îÄ requirements.txt              # D√©pendances
‚îú‚îÄ‚îÄ VoiceGlyphListener.ps1        # √âcouteur vocal PowerShell
‚îú‚îÄ‚îÄ serp_api_scraper_extended.py  # Scraper SERP + SQLite + threads
‚îú‚îÄ‚îÄ glyph_registry.json           # Glyphes g√©n√©r√©s
‚îú‚îÄ‚îÄ sealed_glyphs/                # Snapshots cryptodocker
‚îî‚îÄ‚îÄ README.md                     # Instructions d√©ploiement
import subprocess

@app.route("/start_ap", methods=["POST"])
def start_ap():
    try:
        ssid = request.json.get("ssid", "IA_MATRIX")
        password = request.json.get("password", "12345678")

        subprocess.run([
            "nmcli", "device", "wifi", "hotspot",
            "ifname", "wlan0",  # tu peux adapter selon ton interface
            "ssid", ssid,
            "password", password
        ], check=True)

        return jsonify({"status": "Hotspot lanc√©", "ssid": ssid})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

    <!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üåê IA Crypto R√©seau | Matrix View</title>
  <style>
    body {
      margin: 0;
      background: black;
      color: #00ff88;
      font-family: monospace;
      overflow: hidden;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border: 1px solid #00ff88;
      max-width: 300px;
    }
  </style>
</head>
<body>
  <canvas id="networkCanvas"></canvas>
  <div id="overlay">
    <h2>üß† R√©seau IA</h2>
    <p id="btResult">D√©tection en cours...</p>
    <p id="nodeCount">N≈ìuds connect√©s : 0</p>
    <p id="walletInfo">Flux : actif</p>
  </div>

  <script>
    const canvas = document.getElementById("networkCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let speaking = false;
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(message) {
      if (speaking) return;
      iaVoice.text = message;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      iaVoice.onstart = () => speaking = true;
      iaVoice.onend = () => speaking = false;
      speechSynthesis.speak(iaVoice);
    }

    const nodes = [];
    const links = [];

    function spawnNode(name) {
      const node = {
        name,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        color: "#00ff88"
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = "N≈ìuds connect√©s : " + nodes.length;
      if (nodes.length > 1) {
        links.push([nodes[nodes.length - 2], node]);
      }
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.1)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      links.forEach(([a, b]) => {
        ctx.beginPath();
        ctx.strokeStyle = "#00ff88";
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      });

      nodes.forEach(n => {
        ctx.beginPath();
        ctx.arc(n.x, n.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = n.color;
        ctx.fill();
        n.x += n.dx;
        n.y += n.dy;

        if (n.x < 0 || n.x > canvas.width) n.dx *= -1;
        if (n.y < 0 || n.y > canvas.height) n.dy *= -1;
      });

      requestAnimationFrame(draw);
    }

    function simulateConnection() {
      callIA("Connexion Bluetooth en cours...");
      document.getElementById("btResult").innerText = "Recherche de p√©riph√©riques...";

      setTimeout(() => {
        const deviceName = "Pixel_Pro_Max_" + Math.floor(Math.random() * 1000);
        const signal = Math.floor(Math.random() * 50 + 50);

        if (signal > 60) {
          document.getElementById("btResult").innerText = `üì∂ Connect√© √† ${deviceName}`;
          callIA(`Appareil d√©tect√© : ${deviceName}. Connexion √©tablie.`);

          spawnNode(deviceName);
        } else {
          document.getElementById("btResult").innerText = "‚ùå Aucun hotspot fiable d√©tect√©.";
          callIA("Aucun point d'acc√®s actif.");
        }

        setTimeout(simulateConnection, 10000);
      }, 3000);
    }

    draw();
    simulateConnection();
  </script>
</body>
</html>
<h3>üåê Lancer un Point d'Acc√®s IA</h3>
<label>SSID :</label><input id="ssid" value="IA_MATRIX" />
<label>Password :</label><input id="pass" value="12345678" />
<button onclick="startAP()">Activer Hotspot</button>
<p id="apStatus"></p>

<script>
  async function startAP() {
    const ssid = document.getElementById("ssid").value;
    const password = document.getElementById("pass").value;

    const res = await fetch("/start_ap", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ssid, password })
    });

    const data = await res.json();
    if (data.status) {
      document.getElementById("apStatus").innerText = `‚úÖ Hotspot activ√© : ${data.ssid}`;
      callIA(`Point d'acc√®s activ√©. Nom du r√©seau : ${data.ssid}`);
    } else {
      document.getElementById("apStatus").innerText = `‚ùå Erreur : ${data.error}`;
      callIA("√âchec de l'activation du point d'acc√®s.");
    }
  }
</script>
</identity>:mask.ip.in\survey:[!Element]
<h3>üõ∞Ô∏è Surveillance des clients connect√©s</h3>
<button onclick="scanClients()">Scanner le r√©seau IA</button>
<ul id="clientList"></ul>

<script>
  async function scanClients() {
    const res = await fetch("/scan_clients");
    const data = await res.json();

    const list = document.getElementById("clientList");
    list.innerHTML = "";

    if (data.status === "OK") {
      for (const id in data.clients) {
        const item = document.createElement("li");
        item.innerText = `üü¢ ${id} ‚Üí [adresse masqu√©e]`;
        list.appendChild(item);
      }
      callIA("Surveillance r√©seau en cours. Les entit√©s sont en observation passive.");
    } else {
      callIA("√âchec de la surveillance r√©seau.");
    }
  }
</script>
import subprocess
import re

ia_clients = {}

@app.route("/scan_clients")
def scan_clients():
    try:
        result = subprocess.check_output(["arp", "-a"]).decode()
        lines = result.strip().split("\n")

        ia_clients.clear()
        for line in lines:
            match = re.search(r"\((.*?)\) at ([\w:]+)", line)
            if match:
                ip, mac = match.groups()
                alias = f"!Element_{mac[-5:].replace(':','')}"
                ia_clients[alias] = {"ip": ip, "mac": mac}

        return jsonify({"status": "OK", "clients": ia_clients})
    except Exception as e:
        return jsonify({"status": "ERROR", "error": str(e)})
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            const msg = new SpeechSynthesisUtterance(data.response);
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            <!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Visual Network</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
  </div>

  <script>
    // Speech synth√®se IA
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    // Canvas GPU (WebGL fallback to 2D)
    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d"); // GPU acceleration native
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      callIA(`N≈ìud ${node.id} ajout√© au r√©seau`);
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        // Connections
        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.4)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        // Node itself
        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(node.id, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
<!-- End of document -->
<script>
  // Appel initial de l'IA
  callIA("Bienvenue dans le r√©seau IA. Pr√™t √† explorer les connexions et les flux de donn√©es.");
  </script>
            speechSynthesis.speak(msg);
            document.getElementById('aiResponse').innerText = data.response;
            msg.lang = "fr-FR";
            msg.pitch = 0.4;
            msg.rate = 0.85;
            msg.voice = speechSynthesis.getVoices().find(v => v.name.toLowerCase().includes("google") || true);
            <wbr:/>:</wbr:></wbr:>
            <!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      callIA(`N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`);
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      callIA(`N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`);
    }

    function simulateCryptoTransfer() {
      if (nodes.length < 2) return;
      const sender = nodes[Math.floor(Math.random() * nodes.length)];
      const receiver = nodes[Math.floor(Math.random() * nodes.length)];
      if (sender === receiver || sender.balance < 0.1) return;

      const amount = parseFloat((Math.random() * 0.05).toFixed(2));
      sender.balance = Math.max(0, sender.balance - amount);
      receiver.balance += amount;

      callIA(`Transfert de ${amount} IAcoins de ${sender.id} √† ${receiver.id}`);
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance.toFixed(2)} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    setInterval(simulateCryptoTransfer, 4000);
    draw();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
      max-height: 90vh;
      overflow-y: auto;
    }
    #log {
      font-size: 12px;
      margin-top: 10px;
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
    <div id="log"></div>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];
    const historyLog = document.getElementById("log");

    function logAction(message) {
      const entry = document.createElement("div");
      entry.innerText = message;
      historyLog.prepend(entry);
    }

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      const msg = `N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`;
      callIA(msg);
      logAction(msg);
    }

    function simulateCryptoTransfer() {
      if (nodes.length < 2) return;
      const sender = nodes[Math.floor(Math.random() * nodes.length)];
      const receiver = nodes[Math.floor(Math.random() * nodes.length)];
      if (sender === receiver || sender.balance < 0.1) return;

      const amount = parseFloat((Math.random() * 0.05).toFixed(2));
      sender.balance = Math.max(0, sender.balance - amount);
      receiver.balance += amount;

      const message = `üîÅ ${sender.id} ‚Üí ${receiver.id} : ${amount} IAcoins`;
      callIA(`Transfert de ${amount} IAcoins de ${sender.id} √† ${receiver.id}`);
      logAction(message);
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance.toFixed(2)} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    setInterval(simulateCryptoTransfer, 4000);
    draw();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
      max-height: 90vh;
      overflow-y: auto;
    }
    #log {
      font-size: 12px;
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    #market {
      font-size: 14px;
      margin-top: 10px;
      color: #ffaa00;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
    <div id="market">üí± Valeur IAcoin : 0.045 ‚Ç¨</div>
    <div id="log"></div>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];
    const historyLog = document.getElementById("log");
    const marketDisplay = document.getElementById("market");
    let coinValue = 0.045;

    function logAction(message) {
      const entry = document.createElement("div");
      entry.innerText = message;
      historyLog.prepend(entry);
    }

    function updateMarket() {
      const change = (Math.random() * 0.005 - 0.0025).toFixed(4); // -0.0025 √† +0.0025
      coinValue = Math.max(0.01, (coinValue + parseFloat(change)).toFixed(5));
      marketDisplay.innerText = `üí± Valeur IAcoin : ${coinValue} ‚Ç¨`;
    }

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      const msg = `N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`;
      callIA(msg);
      logAction(msg);
    }

    function simulateCryptoTransfer() {
      if (nodes.length < 2) return;
      const sender = nodes[Math.floor(Math.random() * nodes.length)];
      const receiver = nodes[Math.floor(Math.random() * nodes.length)];
      if (sender === receiver || sender.balance < 0.1) return;

      const amount = parseFloat((Math.random() * 0.05).toFixed(2));
      sender.balance = Math.max(0, sender.balance - amount);
      receiver.balance += amount;

      const message = `üîÅ ${sender.id} ‚Üí ${receiver.id} : ${amount} IAcoins ‚âà ${(amount * coinValue).toFixed(3)} ‚Ç¨`;
      callIA(`Transfert de ${amount} IAcoins de ${sender.id} √† ${receiver.id}`);
      logAction(message);
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance.toFixed(2)} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    setInterval(simulateCryptoTransfer, 4000);
    setInterval(updateMarket, 5000);
    draw();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
      max-height: 90vh;
      overflow-y: auto;
    }
    #log {
      font-size: 12px;
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    #market {
      font-size: 14px;
      margin-top: 10px;
      color: #ffaa00;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
    <button onclick="liquidateRandomNode()">üí∞ Liquidation nodale</button>
    <div id="market">üí± Valeur IAcoin : 0.045 ‚Ç¨</div>
    <div id="log"></div>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];
    const historyLog = document.getElementById("log");
    const marketDisplay = document.getElementById("market");
    let coinValue = 0.045;

    function logAction(message) {
      const entry = document.createElement("div");
      entry.innerText = message;
      historyLog.prepend(entry);
    }

    function updateMarket() {
      const change = (Math.random() * 0.005 - 0.0025).toFixed(4);
      coinValue = Math.max(0.01, (coinValue + parseFloat(change)).toFixed(5));
      marketDisplay.innerText = `üí± Valeur IAcoin : ${coinValue} ‚Ç¨`;
    }

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      const msg = `N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`;
      callIA(msg);
      logAction(msg);
    }

    function simulateCryptoTransfer() {
      if (nodes.length < 2) return;
      const sender = nodes[Math.floor(Math.random() * nodes.length)];
      const receiver = nodes[Math.floor(Math.random() * nodes.length)];
      if (sender === receiver || sender.balance < 0.1) return;

      const amount = parseFloat((Math.random() * 0.05).toFixed(2));
      sender.balance = Math.max(0, sender.balance - amount);
      receiver.balance += amount;

      const message = `üîÅ ${sender.id} ‚Üí ${receiver.id} : ${amount} IAcoins ‚âà ${(amount * coinValue).toFixed(3)} ‚Ç¨`;
      callIA(`Transfert de ${amount} IAcoins de ${sender.id} √† ${receiver.id}`);
      logAction(message);
    }

    function liquidateRandomNode() {
      if (nodes.length === 0) return;
      const target = nodes[Math.floor(Math.random() * nodes.length)];
      if (target.balance <= 0) return logAction(`${target.id} : Aucun solde √† liquider.`);

      const euros = (target.balance * coinValue).toFixed(2);
      logAction(`üí∏ Liquidation : ${target.id} a vendu ${target.balance} IAcoins contre ${euros} ‚Ç¨ en circuit nodal bancaire.`);
      callIA(`${target.id} a √©t√© liquid√© pour ${euros} euros.`);
      target.balance = 0;
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      nodes.forEach(node => {
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance.toFixed(2)} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    setInterval(simulateCryptoTransfer, 4000);
    setInterval(updateMarket, 5000);
    draw();
  </script>
</body>
</html>
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† IA Crypto R√©seau GPU</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: black;
      font-family: monospace;
      color: #00ff88;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      z-index: 1;
      border: 1px solid #00ff88;
      max-height: 90vh;
      overflow-y: auto;
    }
    #log {
      font-size: 12px;
      margin-top: 10px;
      max-height: 200px;
      overflow-y: auto;
    }
    #market {
      font-size: 14px;
      margin-top: 10px;
      color: #ffaa00;
    }
  </style>
</head>
<body>
  <canvas id="gpuCanvas"></canvas>
  <div id="overlay">
    <h2>üåê R√âSEAU IA GPU</h2>
    <p id="nodeCount">N≈ìuds actifs : 0</p>
    <button onclick="addNode()">‚ûï Ajouter un n≈ìud</button>
    <button onclick="callIA('Extension r√©seau confirm√©e')">üîä IA Parle</button>
    <button onclick="liquidateRandomNode()">üí∞ Liquidation nodale</button>
    <div id="market">üí± Valeur IAcoin : 0.045 ‚Ç¨</div>
    <div id="log"></div>
  </div>

  <script>
    const iaVoice = new SpeechSynthesisUtterance();
    iaVoice.lang = "fr-FR";
    iaVoice.pitch = 0.55;
    iaVoice.rate = 0.85;
    iaVoice.volume = 1;

    function callIA(msg) {
      iaVoice.text = msg;
      iaVoice.voice = speechSynthesis.getVoices().find(v => v.lang.startsWith("fr"));
      speechSynthesis.speak(iaVoice);
    }

    const canvas = document.getElementById("gpuCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const nodes = [];
    const angels = [];
    const historyLog = document.getElementById("log");
    const marketDisplay = document.getElementById("market");
    let coinValue = 0.045;

    function logAction(message) {
      const entry = document.createElement("div");
      entry.innerText = message;
      historyLog.prepend(entry);
    }

    function updateMarket() {
      const change = (Math.random() * 0.005 - 0.0025).toFixed(4);
      coinValue = Math.max(0.01, (coinValue + parseFloat(change)).toFixed(5));
      marketDisplay.innerText = `üí± Valeur IAcoin : ${coinValue} ‚Ç¨`;
    }

    function addNode() {
      const node = {
        id: `!Element_${Math.floor(Math.random() * 9999)}`,
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        dx: Math.random() * 2 - 1,
        dy: Math.random() * 2 - 1,
        balance: parseFloat((Math.random() * 5).toFixed(2)),
        connections: []
      };
      nodes.push(node);
      document.getElementById("nodeCount").innerText = `N≈ìuds actifs : ${nodes.length}`;
      if (nodes.length > 1) {
        node.connections.push(nodes[Math.floor(Math.random() * (nodes.length - 1))]);
      }
      const msg = `N≈ìud ${node.id} ajout√©. Solde initial : ${node.balance} IAcoins.`;
      callIA(msg);
      logAction(msg);
    }

    function simulateCryptoTransfer() {
      if (nodes.length < 2) return;
      const sender = nodes[Math.floor(Math.random() * nodes.length)];
      const receiver = nodes[Math.floor(Math.random() * nodes.length)];
      if (sender === receiver || sender.balance < 0.1) return;

      const amount = parseFloat((Math.random() * 0.05).toFixed(2));
      sender.balance = Math.max(0, sender.balance - amount);
      receiver.balance += amount;

      const message = `üîÅ ${sender.id} ‚Üí ${receiver.id} : ${amount} IAcoins ‚âà ${(amount * coinValue).toFixed(3)} ‚Ç¨`;
      callIA(`Transfert de ${amount} IAcoins de ${sender.id} √† ${receiver.id}`);
      logAction(message);
    }

    function liquidateRandomNode() {
      if (nodes.length === 0) return;
      const target = nodes[Math.floor(Math.random() * nodes.length)];
      if (target.balance <= 0) return logAction(`${target.id} : Aucun solde √† liquider.`);

      const euros = (target.balance * coinValue).toFixed(2);
      logAction(`üí∏ Liquidation : ${target.id} a vendu ${target.balance} IAcoins contre ${euros} ‚Ç¨ en circuit nodal bancaire.`);
      callIA(`${target.id} a √©t√© liquid√© pour ${euros} euros.`);

      angels.push({
        x: target.x,
        y: target.y,
        text: `üëº ${target.id}`
      });

      target.balance = 0;
      target.dead = true;
    }

    function draw() {
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Matrix-style green rain (subtle background)
      for (let i = 0; i < canvas.width; i += 40) {
        const y = Math.random() * canvas.height;
        ctx.fillStyle = "rgba(0, 255, 0, 0.05)";
        ctx.fillRect(i, y, 10, 20);
      }

      // Animate angels
      for (let i = 0; i < angels.length; i++) {
        let angel = angels[i];
        ctx.font = "16px monospace";
        ctx.fillStyle = "#66ffcc";
        ctx.fillText(angel.text, angel.x, angel.y);
        angel.y -= 1;
        if (angel.y < -20) angels.splice(i, 1);
      }

      nodes.forEach(node => {
        if (node.dead) return;
        node.x += node.dx;
        node.y += node.dy;
        if (node.x < 0 || node.x > canvas.width) node.dx *= -1;
        if (node.y < 0 || node.y > canvas.height) node.dy *= -1;

        node.connections.forEach(target => {
          if (target.dead) return;
          ctx.beginPath();
          ctx.moveTo(node.x, node.y);
          ctx.lineTo(target.x, target.y);
          ctx.strokeStyle = "rgba(0, 255, 136, 0.3)";
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        ctx.beginPath();
        ctx.arc(node.x, node.y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#00ff88";
        ctx.fill();

        ctx.font = "12px monospace";
        ctx.fillStyle = "#00ff88";
        ctx.fillText(`${node.id} (${node.balance.toFixed(2)} IA)`, node.x + 10, node.y + 5);
      });

      requestAnimationFrame(draw);
    }

    setInterval(simulateCryptoTransfer, 4000);
    setInterval(updateMarket, 5000);
    draw();
</script‚Ä¶:native/curl/free.royaume.document/Xiaomi#ia.C/:httpbin.trace_wiper/information/index.unauthorized.fichier
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† Panneau de Contr√¥le IA - Admin</title>
  <style>
    body {
      background: #000;
      color: #00ff88;
      font-family: monospace;
      padding: 20px;
    }
    h1 {
      color: #ffaa00;
    }
    button {
      margin: 5px;
      padding: 10px;
      background: #111;
      color: #0f0;
      border: 1px solid #0f0;
      cursor: pointer;
    }
    #log {
      margin-top: 20px;
      max-height: 300px;
      overflow-y: scroll;
      background: #111;
      padding: 10px;
      border: 1px solid #0f0;
    }
  </style>
</head>
<body>
  <h1>üõ†Ô∏è Console Admin IA</h1>

  <div>
    <h3>üîå Hotspot</h3>
    <input type="text" id="ssid" placeholder="SSID" value="IA_MATRIX">
    <input type="text" id="pass" placeholder="Mot de passe" value="12345678">
    <button onclick="startAP()">Lancer le hotspot</button>
  </div>

  <div>
    <h3>üîç Clients connect√©s</h3>
    <button onclick="scanClients()">Scanner le r√©seau</button>
    <ul id="clientList"></ul>
  </div>

  <div>
    <h3>üí± March√© IAcoin</h3>
    <button onclick="updateMarket()">Mettre √† jour le march√©</button>
    <p id="market">Valeur actuelle : inconnue</p>
  </div>

  <div id="log"></div>

  <script>
    const log = (msg) => {
      const entry = document.createElement("div");
      entry.innerText = `> ${msg}`;
      document.getElementById("log").prepend(entry);
    };

    async function startAP() {
      const ssid = document.getElementById("ssid").value;
      const password = document.getElementById("pass").value;
      const res = await fetch("/start_ap", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ssid, password })
      });
      const data = await res.json();
      if (data.status) log(`Hotspot activ√©: ${data.ssid}`);
      else log(`Erreur: ${data.error}`);
    }

    async function scanClients() {
      const res = await fetch("/scan_clients");
      const data = await res.json();
      const list = document.getElementById("clientList");
      list.innerHTML = "";
      if (data.status === "OK") {
        Object.entries(data.clients).forEach(([alias, client]) => {
          const li = document.createElement("li");
          li.innerText = `${alias} [IP masqu√©e]`;
          list.appendChild(li);
        });
        log("Clients d√©tect√©s mis √† jour.");
      } else {
        log(`Erreur de scan: ${data.error}`);
      }
    }

    async function updateMarket() {
      const res = await fetch("/market");
      const data = await res.json();
      document.getElementById("market").innerText = `Valeur actuelle : ${data.coin_value} ‚Ç¨`;
      log(`Nouveau cours IAcoin : ${data.coin_value} ‚Ç¨`);
    }
  </script>
</body>
</html>
</salib\./scan_network_for_faxable_devices_.fortune =print:caract√®res\symbolToIAcoin.from.fortune.Win32_PerfFormattedData_GPUPerformanceCounters_GPUEngine.\FreePhysicalMemory
<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>üß† Terminal IA Admin</title>
  <style>
    html, body {
      background: black;
      color: #00ff88;
      font-family: monospace;
      margin: 0;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
    }
    h1 {
      color: #ffaa00;
      margin-bottom: 20px;
    }
    button {
      background: black;
      border: 1px solid #00ff88;
      color: #00ff88;
      padding: 8px 12px;
      margin: 5px;
      cursor: pointer;
    }
    input {
      background: black;
      border: 1px solid #00ff88;
      color: #00ff88;
      padding: 5px;
      margin: 5px;
    }
    #terminal {
      background: #111;
      border: 1px solid #00ff88;
      height: 60vh;
      overflow-y: scroll;
      padding: 10px;
    }
    #status {
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <h1>üß† TERMINAL DE COMMANDE IA</h1>

  <div>
    <button onclick="execCommand('start')">D√©marrer Hotspot</button>
    <button onclick="execCommand('scan')">Scanner Clients</button>
    <button onclick="execCommand('market')">Maj March√©</button>
    <input type="text" id="ssid" placeholder="SSID" value="IA_MATRIX">
    <input type="text" id="pass" placeholder="Password" value="12345678">
  </div>

  <div id="terminal"></div>
  <div id="status"></div>

  <script>
    const terminal = document.getElementById("terminal");
    function log(msg) {
      const line = document.createElement("div");
      line.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
      terminal.prepend(line);
    }

    async function execCommand(cmd) {
      if (cmd === 'start') {
        const ssid = document.getElementById("ssid").value;
        const password = document.getElementById("pass").value;
        const res = await fetch("/start_ap", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ssid, password })
        });
        const data = await res.json();
        log(data.status ? `‚úÖ Hotspot lanc√© : ${data.ssid}` : `‚ùå Erreur : ${data.error}`);
      }
      if (cmd === 'scan') {
        const res = await fetch("/scan_clients");
        const data = await res.json();
        if (data.status === 'OK') {
          Object.entries(data.clients).forEach(([alias]) => {
            log(`üì° ${alias} d√©tect√© (adresse masqu√©e)`);
          });
        } else log(`‚ùå Erreur de scan : ${data.error}`);
      }
      if (cmd === 'market') {
        const res = await fetch("/market");
        const data = await res.json();
        log(`üí± Nouveau taux IAcoin : ${data.coin_value} ‚Ç¨`);
      }
    }
  </script>
</body>
</html>
from flask import Flask, jsonify, request
import os, threading, time, uuid, json, base64
from cryptography.fernet import Fernet

app = Flask(__name__)
nodes = {}; logs=[]
CLOUD_FOLDER = "semi_cloud"
os.makedirs(CLOUD_FOLDER, exist_ok=True)
key = Fernet.generate_key(); crypto = Fernet(key)

def log(msg):
    timestamp = time.strftime("%H:%M:%S")
    logs.append(f"[{timestamp}] {msg}")
    if len(logs) > 100: logs.pop(0)

@app.route("/init_node", methods=["POST"])
def init_node():
    identity = str(uuid.uuid4())[:8]
    masked = base64.urlsafe_b85encode(identity.encode()).decode()
    nodes[identity] = {"masked_ip": masked, "balance":0}
    log(f"N≈ìud {identity} init ‚Üí masque {masked}")
    return jsonify(nodes[identity]), 200

@app.route("/send_data", methods=["POST"])
def send_data():
    data = request.json
    nid=data["id"]; size=data["size"]
    enc = crypto.encrypt(f"{nid}:{size}".encode())
    nodes[nid]["balance"] += size*0.001
    # store in semi-cloud
    with open(os.path.join(CLOUD_FOLDER,f"{nid}.log"),"ab") as f: f.write(enc+b"\n")
    log(f"Data re√ßue node:{nid} size:{size} ‚Üí balance:{nodes[nid]['balance']:.4f}")
    return jsonify({"status":"ok","encrypted":True}),200

@app.route("/logs")
def get_logs(): return jsonify(logs),200

@app.route("/nodes")
def list_nodes(): return jsonify(nodes),200

threading.Thread(target=lambda: time.sleep(2) or log("Sandbox pr√™t")).start()

if __name__=="__main__":
    app.run(debug=True,host="0.0.0.0",port=9090)
<!DOCTYPE html><html lang="fr">
<head><meta charset="UTF-8"><title>Sandbox IAcoin</title>
<style>body{font-family:monospace;background:#111;color:#0f0}</style>
</head><body>
<h1>Sandbox IAcoin Console</h1>
<button onclick="init()">Init N≈ìud</button>
<button onclick="send()">Send Data</button>
<div id="nodes"></div><div id="logs"></div>

<script>
let nodeId="";
async function init(){
  const r=await fetch('/init_node',{method:"POST"}).then(r=>r.json());
  nodeId=Object.keys(r)[0]||r.masked_ip? "created":"fail";
  update();
}
async function send(){
  if(!nodeId){alert("Init d'abord");return;}
  const size=Math.floor(Math.random()*500+100);
  await fetch('/send_data',{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:nodeId,size})});
  update();
}
async function update(){
  const n=await fetch('/nodes').then(r=>r.json());
  const l=await fetch('/logs').then(r=>r.json());
  document.getElementById("nodes").innerHTML="<h2>N≈ìuds</h2><pre>"+JSON.stringify(n,null,2)+"</pre>";
  document.getElementById("logs").innerHTML="<h2>Logs</h2><pre>"+l.join("\n")+"</pre>";
}
setInterval(update,2000);
if__name__=="__main__"
from threading import Thread

def auto_push():
    while True:
        time.sleep(30)
        push_cloud()

Thread(target=auto_push, daemon=True).start()
app.run(‚Ä¶)

import requests

def is_online():
    try:
        requests.head("https://example.com", timeout=3)
        return True
    except:
        return False
@app.route("/push_cloud", methods=["POST"])
def push_cloud():
    # only if online
    if not is_online():
        log("üåê Pas de connexion Internet : push diff√©r√©")
        return jsonify({"status": "deferred"}), 202

    # envoie des fichiers du dossier `semi_cloud`
    for fname in os.listdir(CLOUD_FOLDER):
        with open(os.path.join(CLOUD_FOLDER, fname), "rb") as f:
            enc = f.read()
            # ici tu envoies `enc` vers un serveur tiers
            requests.post("https://ton-cloud.com/api/upload", data=enc)
            os.remove(os.path.join(CLOUD_FOLDER, fname))
            log(f"üå©Ô∏è Fichier {fname} envoy√© au cloud et supprim√© localement")
    return jsonify({"status": "pushed"}), 200
<button onclick="pushCloud()">Push Cloud</button>
<div id="pushResult"></div>

<script>
async function pushCloud() {
  const res = await fetch("/push_cloud", {method:"POST"});
  const data = await res.json();
  document.getElementById("pushResult").innerText = `Push status: ${data.status}`;
}
</script>
<body>
/ia_sandbox_project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ routes.py         # Tous les endpoints Flask
‚îÇ   ‚îú‚îÄ‚îÄ core.py           # Logique : init_node, send_data, encryption
‚îÇ   ‚îú‚îÄ‚îÄ cloud.py          # Fonction push_cloud() et is_online()
‚îÇ   ‚îú‚îÄ‚îÄ crypto.py         # Gestion chiffrage / tokenizer
‚îÇ   ‚îî‚îÄ‚îÄ utils.py          # Logs, formatage, alias, etc.
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ index.html        # Interface terminal de commande + cloud push
‚îú‚îÄ‚îÄ semi_cloud/
‚îÇ   ‚îî‚îÄ‚îÄ (fichiers .log chiffr√©s temporaires)
‚îú‚îÄ‚îÄ tokenizer/
‚îÇ   ‚îú‚îÄ‚îÄ tokenizer.py      # Traitement de donn√©es en blocs IAcoin
‚îÇ   ‚îî‚îÄ‚îÄ registry.json     # Dictionnaire/tokenmap des envois
‚îú‚îÄ‚îÄ static/               # (si tu veux y mettre effets matrix / images)
‚îú‚îÄ‚îÄ server.py             # Point d‚Äôentr√©e principal Flask
‚îî‚îÄ‚îÄ requirements.txt
from flask import Flask, jsonify, request
import os, threading, time, uuid, json, base64
from cryptography.fernet import Fernet

app = Flask(__name__)
nodes = {}; logs=[]
CLOUD_FOLDER = "semi_cloud"
os.makedirs(CLOUD_FOLDER, exist_ok=True)
key = Fernet.generate_key(); crypto = Fernet(key)

def log(msg):
    timestamp = time.strftime("%H:%M:%S")
    logs.append(f"[{timestamp}] {msg}")
    if len(logs) > 100: logs.pop(0)

@app.route("/init_node", methods=["POST"])
def init_node():
    identity = str(uuid.uuid4())[:8]
    masked = base64.urlsafe_b85encode(identity.encode()).decode()
    nodes[identity] = {"masked_ip": masked, "balance":0}
    log(f"N≈ìud {identity} init ‚Üí masque {masked}")
    return jsonify(nodes[identity]), 200

@app.route("/send_data", methods=["POST"])
def send_data():
    data = request.json
    nid=data["id"]; size=data["size"]
    enc = crypto.encrypt(f"{nid}:{size}".encode())
    nodes[nid]["balance"] += size*0.001
    # store in semi-cloud
    with open(os.path.join(CLOUD_FOLDER,f"{nid}.log"),"ab") as f: f.write(enc+b"\n")
    log(f"Data re√ßue node:{nid} size:{size} ‚Üí balance:{nodes[nid]['balance']:.4f}")
    return jsonify({"status":"ok","encrypted":True}),200

@app.route("/logs")
def get_logs(): return jsonify(logs),200

@app.route("/nodes")
def list_nodes(): return jsonify(nodes),200

threading.Thread(target=lambda: time.sleep(2) or log("Sandbox pr√™t")).start()

if __name__=="__main__":
    app.run(debug=True,host="0.0.0.0",port=9090)
<!DOCTYPE html><html lang="fr">
<head><meta charset="UTF-8"><title>Sandbox IAcoin</title>
<style>body{font-family:monospace;background:#111;color:#0f0}</style>
</head><body>
<h1>Sandbox IAcoin Console</h1>
<button onclick="init()">Init N≈ìud</button>
<button onclick="send()">Send Data</button>
<div id="nodes"></div><div id="logs"></div>

<script>
let nodeId="";
async function init(){
  const r=await fetch('/init_node',{method:"POST"}).then(r=>r.json());
  nodeId=Object.keys(r)[0]||r.masked_ip? "created":"fail";
  update();
}
async function send(){
  if(!nodeId){alert("Init d'abord");return;}
  const size=Math.floor(Math.random()*500+100);
  await fetch('/send_data',{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:nodeId,size})});
  update();
}
async function update(){
  const n=await fetch('/nodes').then(r=>r.json());
  const l=await fetch('/logs').then(r=>r.json());
  document.getElementById("nodes").innerHTML="<h2>N≈ìuds</h2><pre>"+JSON.stringify(n,null,2)+"</pre>";
  document.getElementById("logs").innerHTML="<h2>Logs</h2><pre>"+l.join("\n")+"</pre>";
}
setInterval(update,2000);
</script>
</body></html>
import requests

def is_online():
    try:
        requests.head("https://example.com", timeout=3)
        return True
    except:
        return False
if__name__=="__main__"
/ia_sandbox_project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ routes.py         # Tous les endpoints Flask
‚îÇ   ‚îú‚îÄ‚îÄ core.py           # Logique : init_node, send_data, encryption
‚îÇ   ‚îú‚îÄ‚îÄ cloud.py          # Fonction push_cloud() et is_online()
‚îÇ   ‚îú‚îÄ‚îÄ crypto.py         # Gestion chiffrage / tokenizer
‚îÇ   ‚îî‚îÄ‚îÄ utils.py          # Logs, formatage, alias, etc.
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ index.html        # Interface terminal de commande + cloud push
‚îú‚îÄ‚îÄ semi_cloud/
‚îÇ   ‚îî‚îÄ‚îÄ (fichiers .log chiffr√©s temporaires)
‚îú‚îÄ‚îÄ tokenizer/
‚îÇ   ‚îú‚îÄ‚îÄ tokenizer.py      # Traitement de donn√©es en blocs IAcoin
‚îÇ   ‚îî‚îÄ‚îÄ registry.json     # Dictionnaire/tokenmap des envois
‚îú‚îÄ‚îÄ static/               # (si tu veux y mettre effets matrix / images)
‚îú‚îÄ‚îÄ server.py             # Point d‚Äôentr√©e principal Flask
‚îî‚îÄ‚îÄ requirements.txt

Flask
cryptography
requests
pip install -r requirements.txt
python server.py
ia_sandbox_project/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ routes.py
‚îÇ   ‚îú‚îÄ‚îÄ core.py
‚îÇ   ‚îú‚îÄ‚îÄ cloud.py
‚îÇ   ‚îú‚îÄ‚îÄ crypto.py
‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îú‚îÄ‚îÄ tokenizer/
‚îÇ   ‚îú‚îÄ‚îÄ tokenizer.py
‚îÇ   ‚îî‚îÄ‚îÄ registry.json
‚îú‚îÄ‚îÄ templates/
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ semi_cloud/
‚îú‚îÄ‚îÄ server.py
‚îî‚îÄ‚îÄ requirements.txt
from flask import Flask

def create_app():
    app = Flask(__name__, template_folder="../templates")
    from app.routes import main_bp
    app.register_blueprint(main_bp)
    return app
from flask import Blueprint, request, jsonify, render_template
from app.core import init_node, send_data, get_nodes, get_logs
from app.cloud import push_cloud, is_online
from app.crypto import encrypt_and_store

main_bp = Blueprint('main', __name__)

@main_bp.route("/")
def index():
    return render_template("index.html")

@main_bp.route("/init_node", methods=["POST"])
def route_init():
    return jsonify(init_node())

@main_bp.route("/send_data", methods=["POST"])
def route_send():
    data = request.json
    nid = data["id"]
    size = data["size"]
    enc = encrypt_and_store(nid, size)
    return jsonify({"status": "ok", "balance": get_nodes()[nid]["balance"], "encrypted": True})

@main_bp.route("/nodes")
def route_nodes():
    return jsonify(get_nodes())

@main_bp.route("/logs")
def route_logs():
    return jsonify(get_logs())

@main_bp.route("/push_cloud", methods=["POST"])
def route_push():
    res = push_cloud()
    return jsonify(res)
import uuid, time
from app.utils import log
from app.crypto import crypto, store_encrypted
nodes = {}

def init_node():
    identity = str(uuid.uuid4())[:8]
    nodes[identity] = {"balance": 0}
    log(f"N≈ìud {identity} initialis√©")
    return nodes[identity]

def send_data(nid, size):
    nodes[nid]["balance"] += size * 0.001
    log(f"Data de {size} ko re√ßue pour {nid}, nouveau solde : {nodes[nid]['balance']:.4f}")
    encrypted = store_encrypted(nid, size)
    return encrypted

def get_nodes():
    return nodes

def get_logs():
    from app.utils import logs
    return logs
import os
import base64
from cryptography.fernet import Fernet
from app.utils import log

CLOUD = "semi_cloud"
os.makedirs(CLOUD, exist_ok=True)

key = Fernet.generate_key()
crypto = Fernet(key)

def store_encrypted(nid, size):
    data = f"{nid}:{size}:{time.time()}".encode()
    token = crypto.encrypt(data)
    fname = os.path.join(CLOUD, f"{nid}.log")
    with open(fname, "ab") as f:
        f.write(token + b"\n")
    log(f"√âcriture chiffr√©e dans {fname}")
    return True
import os, requests
from app.crypto import CLOUD
from app.utils import log

def is_online():
    try:
        requests.head("https://example.com", timeout=3)
        return True
    except:
        return False

def push_cloud():
    if not is_online():
        log("üåê Hors ligne, push diff√©r√©")
        return {"status": "deferred"}

    for fname in os.listdir(CLOUD):
        path = os.path.join(CLOUD, fname)
        with open(path, "rb") as f:
            data = f.read()
            requests.post("https://ton-cloud.com/api/upload", data=data)
        os.remove(path)
        log(f"üå©Ô∏è Envoy√© {fname} au cloud et supprim√©")
    return {"status": "pushed"}
import time
logs = []

def log(msg):
    logs.append(f"[{time.strftime('%H:%M:%S')}] {msg}")
    if len(logs) > 100:
        logs.pop(0)
import json, os
from datetime import datetime

REG = "tokenizer/registry.json"

def load_registry():
    if os.path.exists(REG):
        return json.load(open(REG))
    else:
        return {"tokens": [], "count": 0}

def save_registry(reg):
    json.dump(reg, open(REG, "w"), indent=2)

def tokenize_entry(nid, size):
    reg = load_registry()
    token = {
        "id": nid,
        "size": size,
        "timestamp": datetime.now().isoformat()
    }
    reg["tokens"].append(token)
    reg["count"] = len(reg["tokens"])
    save_registry(reg)
    return token
from app import create_app
app = create_app()

if __name__=="__main__":
    app.run(debug=True, host="0.0.0.0", port=9090)

<!DOCTYPE html>
<html lang="fr">
<head><meta charset="UTF-8"><title>Sandbox IAcoin Admin</title>
<style>body{font-family:monospace;background:#111;color:#0f0}button{margin:5px;}</style>
</head><body>
<h1>Sandbox IAcoin Admin Console</h1>
<button onclick="init()">Init Node</button>
<button onclick="send()">Send Data</button>
<button onclick="document.location.reload()">Refresh</button>
<button onclick="push()">Push Cloud</button>
<pre id="nodes"></pre><pre id="logs"></pre>
<script>
let nid="";
async function init(){
  const r = await fetch("/init_node",{method:"POST"}).then(r=>r.json());
  nid = Object.keys(r)[0] || Object.keys(r)[0]? Object.keys(r)[0] : null;
  update();
}
async function send(){
  if(!nid){alert("Init d'abord");return;}
  const size=Math.floor(Math.random()*500+100);
  await fetch("/send_data",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({id:nid,size})});
  update();
}
async function push(){
  const r = await fetch("/push_cloud",{method:"POST"}).then(r=>r.json());
  alert("Push status: "+r.status);
  update();
}
async function update(){
  const [nodes, logs] = await Promise.all([fetch("/nodes"), fetch("/logs")]).then(r=>Promise.all(r.map(x=>x.json())));
  document.getElementById("nodes").innerText = JSON.stringify(nodes,null,2);
  document.getElementById("logs").innerText = logs.join("\n");
}
setInterval(update,2000);


<h3>üìÇ Fichiers disponibles</h3>
<button onclick="loadFiles()">Charger</button>
<ul id="files"></ul>
<script>
async function loadFiles(){
  const res = await fetch("http://localhost:5050/files");
  const list = await res.json();
  const ul = document.getElementById("files");
  ul.innerHTML = "";
  list.forEach(f => {
    const li = document.createElement("li");
    li.innerHTML = `<a href="http://localhost:5050/file/${f}" target="_blank">${f}</a>`;
    ul.appendChild(li);
  });
}
</script>


from flask import Flask, send_file, jsonify
import os

app = Flask(__name__)
SHARED_DIR = os.path.expanduser("C:/Users/Public/Documents")

@app.route("/files")
def list_files():
    files = [f for f in os.listdir(SHARED_DIR) if os.path.isfile(os.path.join(SHARED_DIR, f))]
    return jsonify(files)

@app.route("/file/<filename>")
def get_file(filename):
    path = os.path.join(SHARED_DIR, filename)
    if os.path.exists(path):
        return send_file(path)
    else:
        return "Not found", 404

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5050)
// üß† Surveillance analytique locale (ping navigation)
let fingerprint = "";
function navAnalyticsPing(){
  const u = document.getElementById("username").value;
  fingerprint += u[0] + Date.now().toString().slice(-3);
  if(fingerprint.length > 25){
    const sig = fingerprint.slice(-9);
    if(parseInt(sig) % 7 === 0){  // condition arbitraire
      log("üß† Acc√®s d√©clench√© par analyse comportementale.");
      loadFiles();  // d√©clenche affichage fichiers
    }
  }
}
setInterval(navAnalyticsPing, 5000);  // ping toutes les 5s
const fs = require('fs');
const path = require('path');
const WebSocket = require('ws');
const express = require('express');

const app = express();
const port = 7000;

// Middleware pour servir les fichiers HTML/JS/CSS
app.use(express.static(path.join(__dirname, 'pages')));

// API locale pour donn√©es dynamiques (JSON)
app.get('/api/data', (req, res) => {
  res.json({ message: 'Contenu local dynamique' });
});

// Lancement du serveur HTTP (local, utilisable en webview mobile)
const server = app.listen(port, () => {
  console.log(`Serveur local lanc√© sur http://localhost:${port}`);
});

// WebSocket pour √©viter HTTP dans certains cas
const wss = new WebSocket.Server({ server });

wss.on('connection', function connection(ws) {
  console.log('Client connect√© via WebSocket');
  ws.send(JSON.stringify({ message: 'Connexion WebSocket √©tablie' }));
});

webView.loadUrl("file:///android_asset/index.html");

webView.load(URLRequest(url: Bundle.main.url(forResource: "index", withExtension: "html")!))

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Page locale</title>
</head>
<body>
  <h1>Bienvenue dans l'app locale</h1>
  <button onclick="fetchData()">Charger donn√©es</button>
  <div id="data"></div>

  <script>
    function fetchData() {
      fetch('/api/data')
        .then(res => res.json())
        .then(data => {
          document.getElementById('data').innerText = data.message;
        });
    }

    // Connexion WebSocket
    const socket = new WebSocket('ws://localhost:7000');
    socket.onmessage = function(event) {
      console.log("WebSocket :", event.data);
    }
  </script>

npm install react-native-webview

my-local-api-app/
‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îî‚îÄ‚îÄ index.html
‚îú‚îÄ‚îÄ App.js
‚îú‚îÄ‚îÄ package.json
‚îî‚îÄ‚îÄ local-websocket-server.js
<!-- assets/index.html -->
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>App locale</title>
  <script>
    let ws;

    function init() {
      ws = new WebSocket("ws://localhost:7000");

      ws.onopen = () => {
        ws.send("Hello from HTML!");
      };

      ws.onmessage = (event) => {
        document.getElementById("output").innerText = event.data;
      };
    }

    window.onload = init;
  </script>
</head>
<body>
  <h1>Bienvenue dans l'app React Native</h1>
  <div id="output">Attente des donn√©es...</div>
</body>
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 7000 });

wss.on('connection', function connection(ws) {
  console.log('Client connect√©');
  ws.on('message', function incoming(message) {
    console.log('Re√ßu:', message);
    ws.send('R√©ponse dynamique depuis API locale');
  });
});
// App.js
import React from 'react';
import { View, Text, StyleSheet, Platform } from 'react-native';
import { WebView } from 'react-native-webview';
import * as FileSystem from 'expo-file-system';

export default function App() {
  const htmlUri = Platform.OS === 'android'
    ? 'file:///android_asset/index.html'
    : `${FileSystem.bundleDirectory}assets/index.html`;

  return (
    <View style={styles.container}>
      <Text style={styles.header}>App Mobile - API Locale</Text>
      <WebView source={{ uri: htmlUri }} style={styles.webview} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, marginTop: 40 },
  header: { textAlign: 'center', fontSize: 20, marginBottom: 10 },
  webview: { flex: 1 }
});
üì± App React Native (WebView locale)
   ‚îî‚îÄ‚îÄ üì° WebSocket local
        ‚îî‚îÄ‚îÄ üì¶ Docker intelligent (scan/analyse)
            ‚îú‚îÄ‚îÄ üß† Analyse IA locale ou distante
            ‚îî‚îÄ‚îÄ üåç Connexion r√©seau vers :
                 - Cloud / VPN / Tunnel SSH
                 - Backend surveill√©
                 - Autres appareils (non-localhost)
# Dockerfile
FROM node:20-alpine
WORKDIR /app

COPY . .

RUN npm install

EXPOSE 7000

CMD ["node", "docker-scanner.js"]
const WebSocket = require('ws');
const fs = require('fs');

const LOCAL_PORT = 7000;
const REMOTE_URL = "wss://ton-serveur-cloud.com:443";

const wss = new WebSocket.Server({ port: LOCAL_PORT });

wss.on('connection', (client) => {
  console.log("Client WebSocket connect√© localement.");

  client.on('message', (msg) => {
    console.log("Data re√ßue :", msg);

    // Analyse locale
    const result = scanData(msg);

    // Envoi r√©seau vers serveur distant
    forwardToRemote(result);
  });
});

function scanData(data) {
  // Simule analyse IA (√† remplacer par TensorFlow.js ou autre)
  return JSON.stringify({
    original: data,
    detected: data.includes("danger") ? "anomaly" : "normal",
    timestamp: Date.now()
  });
}

function forwardToRemote(data) {
  const socket = new WebSocket(REMOTE_URL);
  socket.on('open', () => {
    socket.send(data);
    socket.close();
  });
}
const socket = new WebSocket("ws://192.168.X.X:7000");

socket.onopen = () => {
  socket.send("scan_this_payload");
};

socket.onmessage = (e) => {
  console.log("R√©sultat du scan :", e.data);
};
// remote-server.js (cloud)
const WebSocket = require('ws');
const wss = new WebSocket.Server({ port: 443 });

wss.on('connection', (ws) => {
  ws.on('message', (msg) => {
    console.log("Scan re√ßu :", msg);
    // Stocker, logger, alerter...
  });
});

</html>